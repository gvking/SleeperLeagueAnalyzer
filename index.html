<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sleeper Fantasy Football Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: white;
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .header p {
            color: #cbd5e1;
            margin-bottom: 8px;
        }

        .week-info {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .input-section {
            background: #475569;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 32px;
        }

        .input-group {
            display: flex;
            gap: 16px;
        }

        input[type="text"] {
            flex: 1;
            padding: 8px 16px;
            border-radius: 6px;
            background: #334155;
            color: white;
            border: 1px solid #475569;
            font-size: 16px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        button {
            padding: 8px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        button:hover:not(:disabled) {
            background: #2563eb;
        }

        button:disabled {
            background: #64748b;
            cursor: not-allowed;
        }

        .error {
            margin-top: 16px;
            padding: 12px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 6px;
            color: #fca5a5;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-info {
            background: #475569;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-details h2 {
            font-size: 1.25rem;
            font-weight: bold;
        }

        .user-details .label {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 24px;
        }

        .player-section {
            border-radius: 8px;
            padding: 24px;
        }

        .player-section.my-players {
            background: linear-gradient(135deg, #064e3b 0%, #14532d 100%);
        }

        .player-section.opponent-players {
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .expand-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
        }

        .expand-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .section-header h2 {
            font-size: 1.25rem;
            font-weight: bold;
            flex: 1;
        }

        .player-count {
            font-size: 0.875rem;
            opacity: 0.75;
        }

        .players-list {
            max-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .player-card.collapsed:hover .player-card-content {
            max-height: 200px !important;
            padding-top: 1.5px !important;
        }

        .player-card.collapsed:hover .expand-icon {
            transform: rotate(180deg);
        }

        .player-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .player-card-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding-top 0.3s ease-out;
            padding-top: 0;
        }

        .player-card-content.expanded {
            max-height: 200px;
            padding-top: 1.5px;
        }

        .player-card.collapsed .player-card-content {
            max-height: 0 !important;
            padding-top: 0 !important;
        }

        .player-card.collapsed:not(:hover) .player-card-content {
            max-height: 0 !important;
            padding-top: 0 !important;
        }

        .expand-icon {
            font-size: 0.8rem;
            transition: transform 0.3s ease;
            opacity: 0.6;
            flex-shrink: 0;
            margin-left: 4px;
        }

        .player-card.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .player-details {
            font-size: 0.875rem;
            opacity: 0.75;
            margin-bottom: 4px;
        }

        .player-leagues {
            font-size: 0.75rem;
            opacity: 0.6;
        }

        .player-points {
            text-align: right;
            flex-shrink: 0;
            min-width: 60px;
        }

        .points-value {
            font-size: 1.125rem;
            font-weight: bold;
        }

        .points-label {
            font-size: 0.75rem;
            opacity: 0.6;
        }

        .loading-text {
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .loading {
            animation: spin 1s linear infinite;
        }

        .empty-state {
            text-align: center;
            padding: 48px;
            color: #94a3b8;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }

        .hidden {
            display: none;
        }

        .ai-summary {
            background: linear-gradient(135deg, #1e40af 0%, #3730a3 100%);
            border-radius: 12px;
            margin-top: 32px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .ai-summary-header {
            padding: 20px 24px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }

        .ai-summary-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .ai-summary-header h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0;
        }

        .toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .toggle-icon.rotated {
            transform: rotate(180deg);
        }

        .ai-summary-content {
            padding: 0 24px 24px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .ai-summary-content.expanded {
            max-height: 1000px;
            transition: max-height 0.3s ease-in;
        }

        .summary-section {
            margin-bottom: 20px;
        }

        .summary-section:last-child {
            margin-bottom: 0;
        }

        .summary-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #e2e8f0;
        }

        .insight-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
            border-left: 4px solid #60a5fa;
        }

        .insight-item:last-child {
            margin-bottom: 0;
        }

        .insight-positive {
            border-left-color: #34d399;
            background: rgba(52, 211, 153, 0.1);
        }

        .insight-negative {
            border-left-color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .insight-neutral {
            border-left-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }

        .player-highlight {
            font-weight: 600;
            color: #fbbf24;
        }

        .icon {
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: middle;
        }

        .icon-trophy {
            color: #facc15;
        }

        .icon-trending-up {
            color: #4ade80;
        }

        .icon-trending-down {
            color: #f87171;
        }

        .live-feed {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            border-radius: 12px;
            margin-top: 32px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .live-feed-header {
            padding: 20px 24px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }

        .live-feed-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .live-feed-header h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0;
            flex: 1;
        }

        .live-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
            margin-right: 16px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6b7280;
            transition: background 0.3s;
        }

        .status-dot.live {
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .live-feed-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .live-feed-content.expanded {
            max-height: 600px;
            transition: max-height 0.3s ease-in;
        }

        .live-filters {
            padding: 16px 24px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 24px;
            font-size: 0.875rem;
        }

        .live-filters label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .live-feed-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 0 24px 24px;
        }

        .live-feed-placeholder {
            text-align: center;
            padding: 48px;
            color: rgba(255, 255, 255, 0.7);
        }

        .live-update-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
            border-left: 4px solid #fbbf24;
            animation: slideIn 0.3s ease-out;
        }

        .live-update-item.scoring {
            border-left-color: #34d399;
            background: rgba(52, 211, 153, 0.15);
        }

        .live-update-item.my-player {
            border-left-color: #10b981;
            background: rgba(16, 185, 129, 0.15);
        }

        .live-update-item.opponent-player {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
        }

        .player-indicator {
            font-size: 0.75rem;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .player-indicator.good {
            background: #10b981;
            color: white;
        }

        .player-indicator.bad {
            background: #ef4444;
            color: white;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-10px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .update-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .update-player {
            font-weight: 600;
            color: #fbbf24;
        }

        .update-time {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .update-details {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .update-leagues {
            font-size: 0.75rem;
            color: #6b7280;
            margin: 4px 0;
            font-style: italic;
        }

        .update-points {
            font-size: 0.75rem;
            margin-top: 4px;
            font-weight: 500;
            color: #34d399;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <svg class="icon icon-trophy" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94A5.01 5.01 0 0 0 11 15.9V19H7v2h10v-2h-4v-3.1a5.01 5.01 0 0 0 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z"/>
                </svg>
                Sleeper Fantasy Tracker
                <svg class="icon icon-trophy" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94A5.01 5.01 0 0 0 11 15.9V19H7v2h10v-2h-4v-3.1a5.01 5.01 0 0 0 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z"/>
                </svg>
            </h1>
            <p>Track all your players across multiple leagues</p>
            <p class="week-info" id="weekInfo"></p>
        </div>

        <div class="input-section" id="inputSection">
            <div class="input-group">
                <input type="text" id="usernameInput" placeholder="Enter your Sleeper username">
                <button id="loadButton" onclick="loadUserData()">
                    <span id="buttonText">Load Leagues</span>
                </button>
            </div>
            <div id="errorMessage" class="error hidden"></div>
        </div>

        <div class="user-info hidden" id="userInfo">
            <div class="user-details">
                <span class="label">Logged in as</span>
                <h2 id="displayName"></h2>
                <p class="label" id="leagueCount"></p>
            </div>
            <div style="display: flex; align-items: center; gap: 16px;">
                <div style="display: flex; align-items: center; gap: 16px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label for="weekSelector" style="font-size: 0.875rem; color: #cbd5e1;">Week:</label>
                        <select id="weekSelector" onchange="changeWeek()" style="padding: 4px 8px; border-radius: 4px; background: #334155; color: white; border: 1px solid #475569;">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="startersOnly" onchange="toggleStarters()" checked style="cursor: pointer;">
                        <label for="startersOnly" style="font-size: 0.875rem; color: #cbd5e1; cursor: pointer;">Starters Only</label>
                    </div>
                    <button onclick="resetApp()">Change User</button>
                </div>
            </div>
        </div>

        <div class="players-grid" id="playersGrid"></div>

        <!-- AI Summary Section -->
        <!-- Live Feed Section -->
        <div class="live-feed hidden" id="liveFeed">
            <div class="live-feed-header" onclick="toggleLiveFeed()">
                <h3>🔴 Live Fantasy Updates</h3>
                <div class="live-status">
                    <span class="status-dot" id="liveStatusDot"></span>
                    <span id="liveStatusText">Offline</span>
                </div>
                <span class="toggle-icon" id="liveFeedToggle">▼</span>
            </div>
            <div class="live-feed-content" id="liveFeedContent">
                <div class="live-filters">
                    <label>
                        <input type="checkbox" id="filterMyPlayers"> My Players Only
                    </label>
                    <label>
                        <input type="checkbox" id="filterScoringPlays"> Scoring Plays Only
                    </label>
                </div>
                <div class="live-feed-list" id="liveFeedList">
                    <div class="live-feed-placeholder">
                        <p>🏈 Live updates will appear here during game time</p>
                        <p style="font-size: 0.875rem; opacity: 0.7;">Updates refresh every 30 seconds</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="ai-summary hidden" id="aiSummary">
            <div class="ai-summary-header" onclick="toggleAISummary()">
                <h3>🤖 Week Analysis & Strategy</h3>
                <span class="toggle-icon" id="summaryToggle">▼</span>
            </div>
            <div class="ai-summary-content" id="summaryContent">
                <div class="summary-section">
                    <h4>🎯 Key Players This Week</h4>
                    <div id="keyPlayers"></div>
                </div>
                <div class="summary-section">
                    <h4>📊 Win Scenarios</h4>
                    <div id="winScenarios"></div>
                </div>
                <div class="summary-section">
                    <h4>⚡ Week Outlook</h4>
                    <div id="weekOutlook"></div>
                </div>
            </div>
        </div>

        <div class="empty-state hidden" id="emptyState">
            <svg fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>
            </svg>
            <p>No active matchups found for this week</p>
            <p style="font-size: 0.875rem; margin-top: 8px;">Your leagues might not have started yet or matchups aren't set</p>
        </div>
    </div>

    <script>
        let currentWeek = 1;
        let selectedWeek = 1;
        let currentSeason = '2025';
        let currentSeasonType = 'regular';
        let userData = null;
        let leagues = [];
        let allPlayers = {};
        let myPlayers = {};
        let opponentPlayers = {};
        let playerStats = {};
        let cachedPlayerLookup = new Map();
        let nflSchedule = {};
        let isLoading = false;
        let aiSummaryExpanded = false;
        let showOnlyStarters = true;
        let weekChangeTimeout = null;
        let liveFeedExpanded = false;
        let liveUpdateTimeout = null;
        let currentPollingInterval = 5000; // Start with 5 seconds
        const MIN_POLLING_INTERVAL = 5000; // 5 seconds minimum
        const MAX_POLLING_INTERVAL = 15000; // 15 seconds maximum
        let lastUpdateCount = 0;
        let liveFeedData = [];
        let lastUpdateTime = {};

        const domCache = {
            playersGrid: null,
            userInfo: null,
            inputSection: null,
            weekSelector: null,
            liveFeed: null,
            liveFeedList: null,
            liveStatusDot: null,
            liveStatusText: null
        };
        
        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('SleeperPlayerDB', 1);

                req.onerror = () => reject(req.error);
                req.onsuccess = () => resolve(req.result);

                req.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('players')) {
                        db.createObjectStore('players', { keyPath: 'season' });
                    }
                };
            });
        }
        
        async function getCachedPlayers(season) {
            try {
                const db = await openDB();
                const transaction = db.transaction(['players'], 'readonly');
                const store = transaction.objectStore('players');
                const req = store.get(season);

                return new Promise((resolve, reject) => {
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => resolve(req.result?.data);
                });
            } catch (error) {
                return null;
            }
        }
        
        async function cachePlayers(season, playerData) {
            try {
                const db = await openDB();
                const transaction = db.transaction(['players'], 'readwrite');
                const store = transaction.objectStore('players');
                store.put({ season, data: playerData, timestamp: Date.now() });
            } catch (error) {
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            domCache.playersGrid = document.getElementById('playersGrid');
            domCache.userInfo = document.getElementById('userInfo');
            domCache.inputSection = document.getElementById('inputSection');
            domCache.weekSelector = document.getElementById('weekSelector');
            domCache.liveFeed = document.getElementById('liveFeed');
            domCache.liveFeedList = document.getElementById('liveFeedList');
            domCache.liveStatusDot = document.getElementById('liveStatusDot');
            domCache.liveStatusText = document.getElementById('liveStatusText');

            fetchNFLState();

            const username = getUsernameFromURL();
            if (username) {
                document.getElementById('usernameInput').value = username;
                loadUserData();
            }

            document.getElementById('usernameInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    loadUserData();
                }
            });
        });
        
        function getUsernameFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            if (urlParams.has('username')) {
                return urlParams.get('username');
            }

            if (urlParams.has('user')) {
                return urlParams.get('user');
            }

            const firstParam = urlParams.keys().next().value;
            if (firstParam && !urlParams.get(firstParam)) {
                return firstParam;
            }

            const path = window.location.pathname;
            const hash = window.location.hash;

            const pathParts = path.split('/');
            if (pathParts.length > 1 && pathParts[pathParts.length - 1] && pathParts[pathParts.length - 1] !== 'index.html') {
                return pathParts[pathParts.length - 1];
            }

            if (hash && hash.startsWith('#')) {
                return hash.substring(1);
            }

            return null;
        }
        
        function updateURL(username) {
            if (!username) return;

            const url = new URL(window.location);
            url.searchParams.set('username', username);
            window.history.replaceState({username: username}, '', url.toString());
        }

        async function fetchNFLState() {
            try {
                const response = await fetch('https://api.sleeper.app/v1/state/nfl');
                const data = await response.json();
                
                currentWeek = data.week || 1;
                selectedWeek = currentWeek; // Default to current week
                currentSeason = data.season || '2025';
                currentSeasonType = data.season_type || 'regular';
                
                // Fetch NFL schedule for the season
                await fetchNFLSchedule();
                
                updateWeekInfo();
            } catch (error) {
                console.error('Error fetching NFL state:', error);
                currentSeason = '2025';
                currentSeasonType = 'regular';
                currentWeek = 1;
                selectedWeek = 1;

                await fetchNFLSchedule();
                
                updateWeekInfo();
            }
        }
        
        async function cleanupOldScheduleCache() {
            try {
                const keys = Object.keys(localStorage);
                const scheduleKeys = keys.filter(key => key.startsWith('nfl_schedule_'));

                scheduleKeys.forEach(key => {
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        // Remove cache older than 7 days or from previous seasons
                        if (!data.timestamp ||
                            Date.now() - data.timestamp > 7 * 24 * 60 * 60 * 1000 ||
                            !key.includes(currentSeason)) {
                            localStorage.removeItem(key);
                        }
                    } catch (e) {
                        localStorage.removeItem(key); // Remove corrupted cache
                    }
                });
            } catch (error) {
                console.warn('Error cleaning schedule cache:', error);
            }
        }

        async function getCachedSchedule(season) {
            try {
                const cacheKey = `nfl_schedule_${season}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const data = JSON.parse(cached);
                    if (data.timestamp && Date.now() - data.timestamp < 90 * 24 * 60 * 60 * 1000) { // 3 months
                        return data.schedule;
                    }
                }
            } catch (error) {
                console.warn('Error reading cached schedule:', error);
            }
            return null;
        }

        async function cacheSchedule(season, scheduleData) {
            try {
                const cacheKey = `nfl_schedule_${season}`;
                const data = {
                    schedule: scheduleData,
                    timestamp: Date.now()
                };
                localStorage.setItem(cacheKey, JSON.stringify(data));
            } catch (error) {
                console.warn('Error caching schedule:', error);
            }
        }

        async function fetchWeekSchedule(week) {
            if (nflSchedule[week]) {
                return; // Already loaded
            }

            // Check if we have this week in cache
            const cachedSchedule = await getCachedSchedule(currentSeason);
            if (cachedSchedule && cachedSchedule[week]) {
                nflSchedule[week] = cachedSchedule[week];
                console.log(`Week ${week} schedule loaded from cache`);
                return;
            }

            try {
                const response = await fetch(`https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=${currentSeason}&seasontype=2&week=${week}`);
                const data = await response.json();

                if (data.events && data.events.length > 0) {
                    nflSchedule[week] = {};

                    data.events.forEach(game => {
                        if (game.competitions && game.competitions[0] && game.competitions[0].competitors) {
                            const competitors = game.competitions[0].competitors;
                            const homeTeam = competitors.find(c => c.homeAway === 'home');
                            const awayTeam = competitors.find(c => c.homeAway === 'away');

                            if (homeTeam && awayTeam) {
                                const homeAbbr = homeTeam.team.abbreviation;
                                const awayAbbr = awayTeam.team.abbreviation;

                                nflSchedule[week][homeAbbr] = {
                                    opponent: awayAbbr,
                                    isHome: true
                                };
                                nflSchedule[week][awayAbbr] = {
                                    opponent: homeAbbr,
                                    isHome: false
                                };
                            }
                        }
                    });
                    console.log(`Week ${week} schedule loaded from ESPN API`);

                    // Update cache with new data (throttled)
                    if (!fetchWeekSchedule.lastCacheUpdate || Date.now() - fetchWeekSchedule.lastCacheUpdate > 5000) {
                        await cacheSchedule(currentSeason, nflSchedule);
                        fetchWeekSchedule.lastCacheUpdate = Date.now();
                    }
                } else {
                    // No games this week, mark as empty
                    nflSchedule[week] = {};
                }
            } catch (error) {
                console.warn(`Error fetching week ${week} schedule:`, error);
                nflSchedule[week] = {}; // Mark as attempted
            }
        }

        async function fetchNFLSchedule() {
            try {
                // Clean up old cache entries
                await cleanupOldScheduleCache();

                // Load cached schedule first
                const cachedSchedule = await getCachedSchedule(currentSeason);
                if (cachedSchedule) {
                    nflSchedule = { ...cachedSchedule };
                    console.log('Schedule loaded from cache');
                }

                // Only fetch current week initially for immediate use
                if (!nflSchedule[currentWeek]) {
                    await fetchWeekSchedule(currentWeek);
                }

                // Preload adjacent weeks in background (non-blocking)
                setTimeout(async () => {
                    const adjacentWeeks = [
                        Math.max(1, currentWeek - 1),
                        Math.min(18, currentWeek + 1)
                    ].filter(week => !nflSchedule[week]);

                    for (const week of adjacentWeeks) {
                        await fetchWeekSchedule(week);
                    }
                }, 100);

                console.log('Initial NFL schedule loaded');
                return;

            } catch (error) {
                console.error('Error fetching NFL schedule from ESPN API:', error);
            }

            // Fallback to hardcoded schedule if ESPN API fails
            const hardcodedSchedule = {
                1: {
                    'KC': { opponent: 'BAL', isHome: true }, 'BAL': { opponent: 'KC', isHome: false },
                    'LAR': { opponent: 'DET', isHome: true }, 'DET': { opponent: 'LAR', isHome: false },
                    'PHI': { opponent: 'GB', isHome: true }, 'GB': { opponent: 'PHI', isHome: false },
                    'BUF': { opponent: 'ARI', isHome: true }, 'ARI': { opponent: 'BUF', isHome: false },
                    'PIT': { opponent: 'ATL', isHome: true }, 'ATL': { opponent: 'PIT', isHome: false },
                    'MIN': { opponent: 'NYG', isHome: true }, 'NYG': { opponent: 'MIN', isHome: false },
                    'IND': { opponent: 'HOU', isHome: true }, 'HOU': { opponent: 'IND', isHome: false },
                    'JAX': { opponent: 'MIA', isHome: true }, 'MIA': { opponent: 'JAX', isHome: false },
                    'CLE': { opponent: 'DAL', isHome: true }, 'DAL': { opponent: 'CLE', isHome: false },
                    'CAR': { opponent: 'NO', isHome: true }, 'NO': { opponent: 'CAR', isHome: false },
                    'CHI': { opponent: 'TEN', isHome: true }, 'TEN': { opponent: 'CHI', isHome: false },
                    'NE': { opponent: 'CIN', isHome: true }, 'CIN': { opponent: 'NE', isHome: false },
                    'LV': { opponent: 'LAC', isHome: true }, 'LAC': { opponent: 'LV', isHome: false },
                    'TB': { opponent: 'WAS', isHome: true }, 'WAS': { opponent: 'TB', isHome: false },
                    'SF': { opponent: 'NYJ', isHome: true }, 'NYJ': { opponent: 'SF', isHome: false },
                    'SEA': { opponent: 'DEN', isHome: true }, 'DEN': { opponent: 'SEA', isHome: false }
                },
                2: {
                    'KC': { opponent: 'CIN', isHome: true }, 'CIN': { opponent: 'KC', isHome: false },
                    'BUF': { opponent: 'MIA', isHome: true }, 'MIA': { opponent: 'BUF', isHome: false },
                    'BAL': { opponent: 'LV', isHome: true }, 'LV': { opponent: 'BAL', isHome: false },
                    'LAC': { opponent: 'CAR', isHome: true }, 'CAR': { opponent: 'LAC', isHome: false },
                    'NO': { opponent: 'DAL', isHome: true }, 'DAL': { opponent: 'NO', isHome: false },
                    'NYG': { opponent: 'WAS', isHome: true }, 'WAS': { opponent: 'NYG', isHome: false },
                    'IND': { opponent: 'GB', isHome: true }, 'GB': { opponent: 'IND', isHome: false },
                    'DET': { opponent: 'TB', isHome: true }, 'TB': { opponent: 'DET', isHome: false },
                    'ATL': { opponent: 'PHI', isHome: true }, 'PHI': { opponent: 'ATL', isHome: false },
                    'CLE': { opponent: 'JAX', isHome: true }, 'JAX': { opponent: 'CLE', isHome: false },
                    'HOU': { opponent: 'CHI', isHome: true }, 'CHI': { opponent: 'HOU', isHome: false },
                    'TEN': { opponent: 'NYJ', isHome: true }, 'NYJ': { opponent: 'TEN', isHome: false },
                    'NE': { opponent: 'SEA', isHome: true }, 'SEA': { opponent: 'NE', isHome: false },
                    'DEN': { opponent: 'PIT', isHome: true }, 'PIT': { opponent: 'DEN', isHome: false },
                    'SF': { opponent: 'MIN', isHome: true }, 'MIN': { opponent: 'SF', isHome: false },
                    'LAR': { opponent: 'ARI', isHome: true }, 'ARI': { opponent: 'LAR', isHome: false }
                }
            };

            nflSchedule = hardcodedSchedule;
            console.log('Using fallback hardcoded schedule');
        }
        
        async function preloadWeeksAround(targetWeek) {
            const weeksToPreload = [
                Math.max(1, targetWeek - 1),
                targetWeek,
                Math.min(18, targetWeek + 1)
            ].filter(week => !nflSchedule[week]);

            if (weeksToPreload.length > 0) {
                setTimeout(async () => {
                    for (const week of weeksToPreload) {
                        await fetchWeekSchedule(week);
                    }
                }, 50);
            }
        }

        async function getPlayerMatchup(playerTeam, week) {
            // Fetch schedule for this week if not already loaded
            if (!nflSchedule[week]) {
                await fetchWeekSchedule(week);
                // Preload adjacent weeks in background
                preloadWeeksAround(week);
            }

            if (!nflSchedule[week] || !nflSchedule[week][playerTeam]) {
                // Check if this is a known bye week (week exists but team isn't in it)
                if (nflSchedule[week] && Object.keys(nflSchedule[week]).length > 0) {
                    return 'Bye Week';
                }
                return null;
            }

            const matchup = nflSchedule[week][playerTeam];
            const vs = matchup.isHome ? 'vs' : '@';
            return `${playerTeam} ${vs} ${matchup.opponent}`;
        }
        
        function generateFallbackProjection(position, team) {
            const positionAverages = {
                'QB': { min: 14, max: 28, avg: 19.5 },
                'RB': { min: 5, max: 22, avg: 12.8 },
                'WR': { min: 6, max: 20, avg: 11.4 },
                'TE': { min: 4, max: 16, avg: 9.2 },
                'K': { min: 6, max: 12, avg: 8.5 },
                'DEF': { min: 4, max: 15, avg: 8.8 }
            };

            const pos = positionAverages[position] || positionAverages['WR'];

            const teamHash = team ? team.split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0) : 42;

            const pseudoRandom = Math.abs(teamHash % 1000) / 1000;

            const range = pos.max - pos.min;
            const projection = pos.min + (pseudoRandom * range);

            return Math.round(projection * 10) / 10;
        }

        function updateWeekInfo() {
            const weekInfo = document.getElementById('weekInfo');
            if (selectedWeek === currentWeek) {
                weekInfo.textContent = `NFL Week ${selectedWeek} (Current) · ${currentSeason} Season`;
            } else if (selectedWeek < currentWeek) {
                weekInfo.textContent = `NFL Week ${selectedWeek} (Past) · ${currentSeason} Season`;
            } else {
                weekInfo.textContent = `NFL Week ${selectedWeek} (Future) · ${currentSeason} Season`;
            }
        }

        function populateWeekSelector() {
            domCache.weekSelector.innerHTML = '';

            for (let week = 1; week <= 18; week++) {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                if (week === selectedWeek) {
                    option.selected = true;
                }
                domCache.weekSelector.appendChild(option);
            }
        }

        async function changeWeek() {
            if (isLoading) return;

            if (weekChangeTimeout) {
                clearTimeout(weekChangeTimeout);
            }

            selectedWeek = parseInt(domCache.weekSelector.value);
            updateWeekInfo();

            if (userData) {
                weekChangeTimeout = setTimeout(async () => {
                    isLoading = true;
                    showLoadingState();

                    try {
                        await processLeagues();
                        displayPlayers();
                    } catch (error) {
                        console.error('Error loading week data:', error);
                    } finally {
                        hideLoadingState();
                        isLoading = false;
                        weekChangeTimeout = null;
                    }
                }, 300);
            }
        }
        
        function showLoadingState() {
            domCache.playersGrid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 48px; color: #94a3b8;">
                    <div class="loading" style="width: 40px; height: 40px; margin: 0 auto 16px; border: 3px solid #475569; border-top: 3px solid #3b82f6; border-radius: 50%;"></div>
                    <p>Loading Week ${selectedWeek} data...</p>
                    <p style="font-size: 0.875rem; margin-top: 8px; opacity: 0.7;">Fetching matchups and player stats</p>
                </div>
            `;
        }
        
        function hideLoadingState() {
            // Placeholder
        }

        async function loadUserData() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) return;

            const button = document.getElementById('loadButton');
            const buttonText = document.getElementById('buttonText');
            const errorDiv = document.getElementById('errorMessage');

            errorDiv.classList.add('hidden');
            button.disabled = true;
            buttonText.innerHTML = '<span class="loading-text">⟳</span> Loading...';

            try {
                const userResponse = await fetch(`https://api.sleeper.app/v1/user/${username}`);
                if (!userResponse.ok) throw new Error('Failed to connect to Sleeper API');
                userData = await userResponse.json();

                if (!userData || !userData.user_id) {
                    throw new Error(`User "${username}" not found. Please check the username and try again.`);
                }

                const leaguesResponse = await fetch(`https://api.sleeper.app/v1/user/${userData.user_id}/leagues/nfl/${currentSeason}`);
                leagues = await leaguesResponse.json();

                if (!leagues || !Array.isArray(leagues)) {
                    leagues = [];
                }

                await processLeagues();

                displayUserInfo();
                populateWeekSelector();
                displayPlayers();

                updateURL(username);

            } catch (error) {
                errorDiv.textContent = error.message || 'An error occurred';
                errorDiv.classList.remove('hidden');
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Load Leagues';
            }
        }

        async function processLeagues() {
            allPlayers = {};
            myPlayers = {};
            opponentPlayers = {};

            for (const league of leagues) {
                try {
                    const rostersResponse = await fetch(`https://api.sleeper.app/v1/league/${league.league_id}/rosters`);
                    const rosters = await rostersResponse.json();

                    const matchupsResponse = await fetch(`https://api.sleeper.app/v1/league/${league.league_id}/matchups/${selectedWeek}`);
                    const matchups = await matchupsResponse.json();

                    if (!matchups || !Array.isArray(matchups) || matchups.length === 0) {
                        continue;
                    }

                    const myRoster = rosters.find(r => r.owner_id === userData.user_id);

                    if (myRoster && myRoster.players) {
                        const myMatchup = matchups.find(m => m.roster_id === myRoster.roster_id);
                        const myStarters = myMatchup?.starters || [];

                        myRoster.players.forEach(playerId => {
                            if (!allPlayers[playerId]) {
                                allPlayers[playerId] = { 
                                    ownedLeagues: [], 
                                    opponentLeagues: [], 
                                    starterOwnedLeagues: [], 
                                    starterOpponentLeagues: [],
                                    isMyStarter: false, 
                                    isOpponentStarter: false 
                                };
                            }
                            allPlayers[playerId].ownedLeagues.push(league.name);

                            if (myStarters.includes(playerId)) {
                                allPlayers[playerId].isMyStarter = true;
                                allPlayers[playerId].starterOwnedLeagues.push(league.name);
                            }
                        });

                        if (myMatchup) {
                            const opponentMatchup = matchups.find(m =>
                                m.matchup_id === myMatchup.matchup_id && m.roster_id !== myRoster.roster_id
                            );

                            if (opponentMatchup) {
                                const opponentRoster = rosters.find(r => r.roster_id === opponentMatchup.roster_id);
                                if (opponentRoster && opponentRoster.players) {
                                    const opponentStarters = opponentMatchup.starters || [];

                                    opponentRoster.players.forEach(playerId => {
                                        if (!allPlayers[playerId]) {
                                            allPlayers[playerId] = { 
                                                ownedLeagues: [], 
                                                opponentLeagues: [], 
                                                starterOwnedLeagues: [], 
                                                starterOpponentLeagues: [],
                                                isMyStarter: false, 
                                                isOpponentStarter: false 
                                            };
                                        }
                                        allPlayers[playerId].opponentLeagues.push(league.name);

                                        if (opponentStarters.includes(playerId)) {
                                            allPlayers[playerId].isOpponentStarter = true;
                                            allPlayers[playerId].starterOpponentLeagues.push(league.name);
                                        }
                                    });
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Error processing league ${league.name}:`, error);
                }
            }

            const allPlayerIds = Object.keys(allPlayers);
            if (allPlayerIds.length > 0) {
                await fetchPlayerStats(allPlayerIds);
            }

            Object.entries(allPlayers).forEach(([playerId, data]) => {
                if (showOnlyStarters && !data.isMyStarter && !data.isOpponentStarter) {
                    return;
                }

                const playerInfo = playerStats[playerId];
                if (!playerInfo || !playerInfo.name || playerInfo.name.includes('undefined') || playerInfo.name === 'N/A') {
                    return;
                }
                
                let ownedCount, opponentCount, ownedLeagues, opponentLeagues;

                if (showOnlyStarters) {
                    ownedCount = data.starterOwnedLeagues.length;
                    opponentCount = data.starterOpponentLeagues.length;
                    ownedLeagues = data.starterOwnedLeagues;
                    opponentLeagues = data.starterOpponentLeagues;
                } else {
                    ownedCount = data.ownedLeagues.length;
                    opponentCount = data.opponentLeagues.length;
                    ownedLeagues = data.ownedLeagues;
                    opponentLeagues = data.opponentLeagues;
                }

                const netImpact = ownedCount - opponentCount;
                const totalLeagues = [...ownedLeagues, ...opponentLeagues];

                if (netImpact > 0) {
                    myPlayers[playerId] = {
                        netImpact: netImpact,
                        totalCount: totalLeagues.length,
                        ownedCount: ownedCount,
                        opponentCount: opponentCount,
                        ownedLeagues: ownedLeagues,
                        opponentLeagues: opponentLeagues,
                        allLeagues: totalLeagues,
                        isMyStarter: data.isMyStarter,
                        isOpponentStarter: data.isOpponentStarter
                    };
                } else if (netImpact < 0) {
                    opponentPlayers[playerId] = {
                        netImpact: netImpact,
                        totalCount: totalLeagues.length,
                        ownedCount: ownedCount,
                        opponentCount: opponentCount,
                        ownedLeagues: ownedLeagues,
                        opponentLeagues: opponentLeagues,
                        allLeagues: totalLeagues,
                        isMyStarter: data.isMyStarter,
                        isOpponentStarter: data.isOpponentStarter
                    };
                } else if (netImpact === 0 && (ownedCount > 0 || opponentCount > 0)) {
                    myPlayers[playerId] = {
                        netImpact: netImpact,
                        totalCount: totalLeagues.length,
                        ownedCount: ownedCount,
                        opponentCount: opponentCount,
                        ownedLeagues: ownedLeagues,
                        opponentLeagues: opponentLeagues,
                        allLeagues: totalLeagues,
                        isMyStarter: data.isMyStarter,
                        isOpponentStarter: data.isOpponentStarter
                    };
                }
            });
            
        }

        async function fetchPlayerStats(playerIds) {
            try {
                let playerDatabase;
                const cachedPlayers = await getCachedPlayers(currentSeason);

                if (cachedPlayers) {
                    playerDatabase = cachedPlayers;
                } else {
                    const playersResponse = await fetch('https://api.sleeper.app/v1/players/nfl');
                    playerDatabase = await playersResponse.json();
                    await cachePlayers(currentSeason, playerDatabase);
                }
                
                let weekStats = {};

                if (selectedWeek <= currentWeek) {
                    try {
                        const statsResponse = await fetch(`https://api.sleeper.app/v1/stats/nfl/${currentSeasonType}/${currentSeason}/${selectedWeek}`);
                        weekStats = await statsResponse.json() || {};
                    } catch (error) {
                        weekStats = {};
                    }
                }
                
                let realProjections = {};
                let missingPlayerIds = [...playerIds];
                let retryAttempt = 0;
                const maxRetries = 2;
                const batchSize = 25;
                const delayBetweenRetries = 1000;
                
                while (missingPlayerIds.length > 0 && retryAttempt < maxRetries) {
                    retryAttempt++;

                    for (let i = 0; i < missingPlayerIds.length; i += batchSize) {
                        const batch = missingPlayerIds.slice(i, i + batchSize);
                        
                        const batchPromises = batch.map(async (playerId) => {
                            try {
                                const projUrl = `https://api.sleeper.com/projections/nfl/player/${playerId}?season_type=${currentSeasonType}&season=${currentSeason}&grouping=week`;
                                const response = await fetch(projUrl);
                                if (response.ok) {
                                    const data = await response.json();
                                    if (data && data[selectedWeek] && data[selectedWeek].stats) {
                                        return { playerId, projection: data[selectedWeek].stats };
                                    }
                                }
                            } catch (error) {
                            }
                            return { playerId, projection: null };
                        });
                        
                        const batchResults = await Promise.all(batchPromises);
                        
                        batchResults.forEach(result => {
                            if (result.projection) {
                                realProjections[result.playerId] = result.projection;
                            }
                        });

                        if (i + batchSize < missingPlayerIds.length) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    const newMissingPlayerIds = playerIds.filter(id => !realProjections[id]);

                    if (newMissingPlayerIds.length === missingPlayerIds.length && retryAttempt > 1) {
                        break;
                    }

                    missingPlayerIds = newMissingPlayerIds;

                    if (missingPlayerIds.length > 0 && retryAttempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenRetries));
                    }
                }
                
                playerStats = {};
                
                for (const playerId of playerIds) {
                    const playerInfo = playerDatabase[playerId];
                    const stats = weekStats[playerId];
                    const proj = realProjections[playerId];

                    if (playerInfo) {
                        let actualPoints = 0;
                        let projectedPoints = 0;

                        if (stats) {
                            actualPoints = calculateFantasyPoints(stats, playerInfo.position);
                        }

                        if (proj) {
                            projectedPoints = proj.pts_ppr || proj.pts_half_ppr || proj.pts_std || 0;
                        } else {
                            continue;
                        }

                        let displayPoints = 0;
                        if (selectedWeek > currentWeek) {
                            displayPoints = projectedPoints;
                        } else if (selectedWeek === currentWeek) {
                            displayPoints = actualPoints > 0 ? actualPoints : projectedPoints;
                        } else {
                            displayPoints = actualPoints;
                        }
                        const matchup = await getPlayerMatchup(playerInfo.team, selectedWeek);

                        playerStats[playerId] = {
                            name: `${playerInfo.first_name} ${playerInfo.last_name}`,
                            position: playerInfo.position,
                            team: playerInfo.team || 'FA',
                            points: displayPoints,
                            actualPoints: actualPoints,
                            projectedPoints: projectedPoints,
                            status: playerInfo.injury_status,
                            matchup: matchup
                        };
                    }
                }
            } catch (error) {
                console.error('Error fetching player stats:', error);
            }
        }
        
        function calculateFantasyPoints(statObj, position) {
            if (!statObj) return 0;

            // If Sleeper already provides calculated points, use those
            if (statObj.pts_ppr !== undefined && statObj.pts_ppr !== null) {
                return statObj.pts_ppr;
            }

            // Otherwise calculate manually for missing data
            if (position === 'K') {
                return (
                    (statObj.fgm || 0) * 3 +
                    (statObj.xpm || 0) * 1 +
                    (statObj.fgm_0_19 || 0) * 3 +
                    (statObj.fgm_20_29 || 0) * 3 +
                    (statObj.fgm_30_39 || 0) * 3 +
                    (statObj.fgm_40_49 || 0) * 4 +
                    (statObj.fgm_50p || 0) * 5
                );
            } else if (position === 'DEF') {
                return (
                    (statObj.def_int || 0) * 2 +
                    (statObj.def_fr || 0) * 2 +
                    (statObj.def_sack || 0) * 1 +
                    (statObj.def_safety || 0) * 2 +
                    (statObj.def_td || 0) * 6 +
                    (statObj.def_blk || 0) * 2
                );
            } else {
                return (
                    (statObj.pass_yd || 0) * 0.04 +
                    (statObj.pass_td || 0) * 4 +
                    (statObj.pass_int || 0) * -1 +
                    (statObj.rush_yd || 0) * 0.1 +
                    (statObj.rush_td || 0) * 6 +
                    (statObj.rec || 0) * 1 +
                    (statObj.rec_yd || 0) * 0.1 +
                    (statObj.rec_td || 0) * 6 +
                    (statObj.fum_lost || 0) * -2
                );
            }
        }

        function displayUserInfo() {
            domCache.inputSection.classList.add('hidden');
            domCache.userInfo.classList.remove('hidden');
            document.getElementById('displayName').textContent = userData.display_name;
            document.getElementById('leagueCount').textContent = `${leagues.length} active league${leagues.length !== 1 ? 's' : ''}`;
        }

        function displayPlayers() {
            domCache.playersGrid.innerHTML = '';

            if (Object.keys(myPlayers).length === 0 && Object.keys(opponentPlayers).length === 0) {
                const emptyState = document.getElementById('emptyState');
                emptyState.classList.remove('hidden');
                document.getElementById('aiSummary').classList.add('hidden');
                
                const emptyMessage = emptyState.querySelector('p');
                const emptySubtext = emptyState.querySelector('p:last-child');

                if (selectedWeek > currentWeek) {
                    emptyMessage.textContent = `No matchups found for Week ${selectedWeek}`;
                    emptySubtext.textContent = 'Matchups for future weeks may not be set yet';
                } else if (selectedWeek < currentWeek) {
                    emptyMessage.textContent = `No matchups found for Week ${selectedWeek}`;
                    emptySubtext.textContent = 'This week may have been a bye week or matchups are not available';
                } else {
                    emptyMessage.textContent = 'No active matchups found for this week';
                    emptySubtext.textContent = 'Your leagues might not have started yet or matchups aren\'t set';
                }
                return;
            }

            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('aiSummary').classList.remove('hidden');
            domCache.liveFeed.classList.remove('hidden');
            startLiveFeed();

            if (Object.keys(myPlayers).length > 0) {
                domCache.playersGrid.innerHTML += createPlayerSection(
                    myPlayers,
                    'Players You Want to Succeed (Net Positive Impact)',
                    'my-players',
                    'trending-up'
                );
            }

            if (Object.keys(opponentPlayers).length > 0) {
                domCache.playersGrid.innerHTML += createPlayerSection(
                    opponentPlayers,
                    'Players You Want to Fail (Net Negative Impact)',
                    'opponent-players',
                    'trending-down'
                );
            }
        }

        function createPlayerSection(players, title, className, iconType) {
            const sortedPlayers = Object.entries(players)
                .map(([id, data]) => ({
                    id,
                    ...data,
                    ...(playerStats[id] || {})
                }))
                .sort((a, b) => {
                    const aStrategicImpact = Math.abs(a.netImpact || 0) * (a.points || 0);
                    const bStrategicImpact = Math.abs(b.netImpact || 0) * (b.points || 0);

                    if (bStrategicImpact !== aStrategicImpact) {
                        return bStrategicImpact - aStrategicImpact;
                    }

                    const aNetImpact = Math.abs(a.netImpact || 0);
                    const bNetImpact = Math.abs(b.netImpact || 0);
                    if (bNetImpact !== aNetImpact) {
                        return bNetImpact - aNetImpact;
                    }

                    return (b.points || 0) - (a.points || 0);
                });

            const iconSvg = iconType === 'trending-up' 
                ? '<svg class="icon icon-trending-up" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>'
                : '<svg class="icon icon-trending-down" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 17h8m0 0v-8m0 8l-8-8-4 4-6-6"></path></svg>';

            let html = `
                <div class="player-section ${className}">
                    <div class="section-header">
                        ${iconSvg}
                        <h2>${title}</h2>
                        <span class="player-count">${sortedPlayers.length} players</span>
                        <button class="expand-toggle" onclick="toggleAllCards(this, '${className}')">
                            🔽 Expand All
                        </button>
                    </div>
                    <div class="players-list">
            `;

            sortedPlayers.forEach(player => {
                html += `
                    <div class="player-card collapsed" onclick="togglePlayerCard(this)" title="Hover to preview or click to pin open">
                        <div class="player-card-header">
                            <div class="player-info">
                                <div class="player-name">${player.name || `Player ${player.id}`}</div>
                            </div>
                            <div class="player-points">
                                <div class="points-value">${(() => {
                                    if (selectedWeek < currentWeek || (selectedWeek === currentWeek && player.actualPoints > 0)) {
                                        return (player.actualPoints || 0).toFixed(1);
                                    } else {
                                        return (player.projectedPoints || player.points || 0).toFixed(1);
                                    }
                                })()}</div>
                                <div class="points-label">
                                    ${selectedWeek > currentWeek ? 'proj' :
                                      selectedWeek === currentWeek && (player.actualPoints === 0 || !player.actualPoints) && player.projectedPoints > 0 ? 'proj' : 'pts'}
                                </div>
                            </div>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div class="player-card-content">
                            <div class="player-details">
                                ${player.position || 'N/A'} - ${player.team}
                                ${player.status ? ` (${player.status})` : ''}
                            </div>
                            <div class="player-matchup" style="font-size: 0.75rem; color: #94a3b8; margin-top: 2px;">
                                ${player.matchup || 'Schedule TBD'}
                            </div>
                            <div class="player-leagues">
                                Net Impact: ${player.netImpact > 0 ? '+' : ''}${player.netImpact}
                                (Own: ${player.ownedCount}, Face: ${player.opponentCount})
                            </div>
                            <div class="player-leagues" style="font-size: 0.7rem; margin-top: 2px;">
                                ${player.ownedCount > 0 ? `Own in: ${player.ownedLeagues.join(', ')}` : ''}
                                ${player.ownedCount > 0 && player.opponentCount > 0 ? ' | ' : ''}
                                ${player.opponentCount > 0 ? `Face in: ${player.opponentLeagues.join(', ')}` : ''}
                            </div>
                            ${selectedWeek === currentWeek && player.actualPoints > 0 && player.projectedPoints > 0 ?
                                `<div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">proj: ${player.projectedPoints.toFixed(1)}</div>` : ''}
                            <div style="font-size: 0.65rem; opacity: 0.5; margin-top: 2px; font-family: monospace;">
                                ID: ${player.id}
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            return html;
        }
        
        function generateAISummary() {
            const allPlayers = [...Object.entries(myPlayers), ...Object.entries(opponentPlayers)]
                .map(([id, data]) => ({
                    id,
                    ...data,
                    ...(playerStats[id] || {})
                }))
                .sort((a, b) => {
                    const aImpact = Math.abs(a.netImpact || 0) * (a.points || 0);
                    const bImpact = Math.abs(b.netImpact || 0) * (b.points || 0);
                    return bImpact - aImpact;
                });
            
            generateKeyPlayers(allPlayers);
            generateWinScenarios();
            generateWeekOutlook(allPlayers);
        }
        
        function generateKeyPlayers(allPlayers) {
            const keyPlayersDiv = document.getElementById('keyPlayers');
            const topPlayers = allPlayers.slice(0, 5);
            
            let html = '';
            topPlayers.forEach((player, index) => {
                const impact = Math.abs(player.netImpact || 0);
                const points = player.points || 0;
                const totalImpact = impact * points;
                
                let insightClass = 'insight-neutral';
                let message = '';
                
                if (player.netImpact > 0) {
                    insightClass = 'insight-positive';
                    message = `You need <span class="player-highlight">${player.name}</span> to have a big week! They're in ${player.ownedCount} of your lineups vs ${player.opponentCount} opponent roster${player.opponentCount !== 1 ? 's' : ''}. Projected: ${points.toFixed(1)} pts`;
                } else if (player.netImpact < 0) {
                    insightClass = 'insight-negative';
                    message = `Hope <span class="player-highlight">${player.name}</span> struggles - they're on ${player.opponentCount} opponent team${player.opponentCount !== 1 ? 's' : ''} vs ${player.ownedCount} of yours. Projected: ${points.toFixed(1)} pts`;
                }
                
                if (message) {
                    html += `<div class="insight-item ${insightClass}">${message}</div>`;
                }
            });
            
            keyPlayersDiv.innerHTML = html;
        }
        
        function generateWinScenarios() {
            const winScenariosDiv = document.getElementById('winScenarios');
            
            let positiveImpact = 0;
            let negativeImpact = 0;

            for (const [playerId, player] of Object.entries(myPlayers)) {
                positiveImpact += Math.abs(player.netImpact) * (playerStats[playerId]?.points || 0);
            }

            for (const [playerId, player] of Object.entries(opponentPlayers)) {
                negativeImpact += Math.abs(player.netImpact) * (playerStats[playerId]?.points || 0);
            }
            
            const totalLeagues = leagues.length;
            const myPlayersCount = Object.keys(myPlayers).length;
            const opponentPlayersCount = Object.keys(opponentPlayers).length;
            
            let html = '';
            
            if (positiveImpact > negativeImpact * 1.2) {
                html += `<div class="insight-item insight-positive">
                    <strong>🎯 Strong Week Ahead:</strong> Your key players are projected for ${positiveImpact.toFixed(0)} total impact points. If they hit projections, you could win ${Math.ceil(totalLeagues * 0.7)}-${totalLeagues} leagues.
                </div>`;
            } else if (negativeImpact > positiveImpact * 1.2) {
                html += `<div class="insight-item insight-negative">
                    <strong>⚠️ Challenging Week:</strong> Opponents have ${negativeImpact.toFixed(0)} total impact points vs your ${positiveImpact.toFixed(0)}. You'll need some players to exceed projections.
                </div>`;
            } else {
                html += `<div class="insight-item insight-neutral">
                    <strong>⚖️ Balanced Week:</strong> Close matchup with ${positiveImpact.toFixed(0)} vs ${negativeImpact.toFixed(0)} impact points. Could go either way - expect to win ${Math.floor(totalLeagues * 0.4)}-${Math.ceil(totalLeagues * 0.6)} leagues.
                </div>`;
            }
            
            if (myPlayersCount > opponentPlayersCount * 1.5) {
                html += `<div class="insight-item insight-positive">
                    <strong>📈 High Upside:</strong> You have ${myPlayersCount} players with positive impact vs ${opponentPlayersCount} negative. Good week for ceiling plays.
                </div>`;
            }
            
            winScenariosDiv.innerHTML = html;
        }
        
        function generateWeekOutlook(allPlayers) {
            const weekOutlookDiv = document.getElementById('weekOutlook');
            
            const positionAnalysis = {};
            allPlayers.forEach(player => {
                const pos = player.position || 'Unknown';
                if (!positionAnalysis[pos]) {
                    positionAnalysis[pos] = { positive: 0, negative: 0, totalImpact: 0 };
                }
                
                const impact = (player.netImpact || 0) * (player.points || 0);
                positionAnalysis[pos].totalImpact += Math.abs(impact);
                
                if (player.netImpact > 0) {
                    positionAnalysis[pos].positive++;
                } else if (player.netImpact < 0) {
                    positionAnalysis[pos].negative++;
                }
            });
            
            let topPosition = null;
            let maxImpact = 0;
            Object.entries(positionAnalysis).forEach(([pos, data]) => {
                if (data.totalImpact > maxImpact) {
                    maxImpact = data.totalImpact;
                    topPosition = { pos, ...data };
                }
            });
            
            let html = '';
            
            if (selectedWeek > currentWeek) {
                html += `<div class="insight-item insight-neutral">
                    <strong>🔮 Future Week ${selectedWeek}:</strong> Planning ahead! Monitor injury reports and weather as the week approaches.
                </div>`;
            } else if (selectedWeek === currentWeek) {
                html += `<div class="insight-item insight-positive">
                    <strong>⚡ This Week:</strong> Games are live! Monitor player status and make any last-minute lineup adjustments.
                </div>`;
            } else {
                html += `<div class="insight-item insight-neutral">
                    <strong>📊 Week ${selectedWeek} Results:</strong> Reviewing past performance to identify trends.
                </div>`;
            }
            
            if (topPosition && topPosition.totalImpact > 50) {
                const ratio = topPosition.positive / (topPosition.negative || 1);
                if (ratio > 2) {
                    html += `<div class="insight-item insight-positive">
                        <strong>🏈 ${topPosition.pos} Advantage:</strong> You have strong ${topPosition.pos} exposure with ${topPosition.positive} positive vs ${topPosition.negative} negative impact players.
                    </div>`;
                } else if (ratio < 0.5) {
                    html += `<div class="insight-item insight-negative">
                        <strong>⚠️ ${topPosition.pos} Concern:</strong> Heavy opposing ${topPosition.pos} exposure (${topPosition.negative} vs ${topPosition.positive}). Monitor this position closely.
                    </div>`;
                }
            }
            
            weekOutlookDiv.innerHTML = html;
        }
        
        function toggleAISummary() {
            const content = document.getElementById('summaryContent');
            const toggle = document.getElementById('summaryToggle');
            
            aiSummaryExpanded = !aiSummaryExpanded;
            
            if (aiSummaryExpanded) {
                content.classList.add('expanded');
                toggle.classList.add('rotated');
                generateAISummary();
            } else {
                content.classList.remove('expanded');
                toggle.classList.remove('rotated');
            }
        }

        function toggleStarters() {
            showOnlyStarters = document.getElementById('startersOnly').checked;
            
            if (userData && Object.keys(allPlayers).length > 0) {
                myPlayers = {};
                opponentPlayers = {};
                
                Object.entries(allPlayers).forEach(([playerId, data]) => {
                    if (showOnlyStarters && !data.isMyStarter && !data.isOpponentStarter) {
                        return;
                    }

                    const playerInfo = playerStats[playerId];
                    if (!playerInfo || !playerInfo.name || playerInfo.name.includes('undefined') || playerInfo.name === 'N/A') {
                        return;
                    }
                    let ownedCount, opponentCount, ownedLeagues, opponentLeagues;
                    
                    if (showOnlyStarters) {
                        ownedCount = data.starterOwnedLeagues.length;
                        opponentCount = data.starterOpponentLeagues.length;
                        ownedLeagues = data.starterOwnedLeagues;
                        opponentLeagues = data.starterOpponentLeagues;
                    } else {
                        ownedCount = data.ownedLeagues.length;
                        opponentCount = data.opponentLeagues.length;
                        ownedLeagues = data.ownedLeagues;
                        opponentLeagues = data.opponentLeagues;
                    }
                    
                    const netImpact = ownedCount - opponentCount;
                    const totalLeagues = [...ownedLeagues, ...opponentLeagues];
                    
                    if (netImpact > 0) {
                        myPlayers[playerId] = {
                            netImpact: netImpact,
                            totalCount: totalLeagues.length,
                            ownedCount: ownedCount,
                            opponentCount: opponentCount,
                            ownedLeagues: ownedLeagues,
                            opponentLeagues: opponentLeagues,
                            allLeagues: totalLeagues,
                            isMyStarter: data.isMyStarter,
                            isOpponentStarter: data.isOpponentStarter
                        };
                    } else if (netImpact < 0) {
                        opponentPlayers[playerId] = {
                            netImpact: netImpact,
                            totalCount: totalLeagues.length,
                            ownedCount: ownedCount,
                            opponentCount: opponentCount,
                            ownedLeagues: ownedLeagues,
                            opponentLeagues: opponentLeagues,
                            allLeagues: totalLeagues,
                            isMyStarter: data.isMyStarter,
                            isOpponentStarter: data.isOpponentStarter
                        };
                    }
                });
                
                displayPlayers();
            }
        }

        function resetApp() {
            userData = null;
            leagues = [];
            allPlayers = {};
            myPlayers = {};
            opponentPlayers = {};
            playerStats = {};
            nflSchedule = {};
            isLoading = false;
            
            document.getElementById('usernameInput').value = '';
            document.getElementById('inputSection').classList.remove('hidden');
            document.getElementById('userInfo').classList.add('hidden');
            document.getElementById('playersGrid').innerHTML = '';
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('aiSummary').classList.add('hidden');
            
            const url = new URL(window.location);
            url.search = '';
            window.history.replaceState({}, '', url.toString());
        }

        function toggleLiveFeed() {
            const content = document.getElementById('liveFeedContent');
            const toggle = document.getElementById('liveFeedToggle');

            liveFeedExpanded = !liveFeedExpanded;

            if (liveFeedExpanded) {
                content.classList.add('expanded');
                toggle.classList.add('rotated');
            } else {
                content.classList.remove('expanded');
                toggle.classList.remove('rotated');
            }
        }

        async function startLiveFeed() {
            if (liveUpdateTimeout) clearTimeout(liveUpdateTimeout);
            currentPollingInterval = MIN_POLLING_INTERVAL; // Reset to fast polling

            domCache.liveStatusText.textContent = 'Connecting...';


            await fetchLiveUpdates();
            domCache.liveStatusText.textContent = `Live (${currentPollingInterval / 1000}s)`;
            scheduleNextUpdate();
        }

        function scheduleNextUpdate() {
            if (liveUpdateTimeout) clearTimeout(liveUpdateTimeout);

            domCache.liveStatusText.textContent = `Live (${currentPollingInterval / 1000}s)`;

            liveUpdateTimeout = setTimeout(async () => {
                const beforeCount = liveFeedData.length;
                await fetchLiveUpdates();
                const afterCount = liveFeedData.length;

                if (afterCount > beforeCount) {
                    currentPollingInterval = MIN_POLLING_INTERVAL;
                } else {
                        const newInterval = Math.min(currentPollingInterval + 2500, MAX_POLLING_INTERVAL);
                    if (newInterval !== currentPollingInterval) {
                    }
                    currentPollingInterval = newInterval;
                }

                scheduleNextUpdate(); // Schedule the next update
            }, currentPollingInterval);
        }

        function stopLiveFeed() {
            if (liveUpdateTimeout) {
                clearTimeout(liveUpdateTimeout);
                liveUpdateTimeout = null;
            }
            domCache.liveStatusDot.classList.remove('live');
            domCache.liveStatusText.textContent = 'Offline';
        }

        async function fetchLiveUpdates() {
            try {
                const response = await fetch(`https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=${currentSeason}&seasontype=2&week=${selectedWeek}`);
                const data = await response.json();


                if (data.events && data.events.length > 0) {
                    const liveGames = data.events.filter(e => e.status.type.state === 'in');
                    const completedGames = data.events.filter(e => e.status.type.state === 'post');

                    if (liveGames.length > 0) {
                        domCache.liveStatusDot.classList.add('live');
                        domCache.liveStatusText.textContent = `Live (${liveGames.length})`;
                    } else if (completedGames.length > 0) {
                        domCache.liveStatusDot.classList.remove('live');
                        domCache.liveStatusText.textContent = `${completedGames.length} Completed`;
                    } else {
                        domCache.liveStatusDot.classList.remove('live');
                        domCache.liveStatusText.textContent = 'Scheduled';
                    }

                    processLiveGameData(data.events);
                } else {
                    domCache.liveStatusDot.classList.remove('live');
                    domCache.liveStatusText.textContent = 'No Games';
                }
            } catch (error) {
                console.error('Live feed error:', error);
                domCache.liveStatusDot.classList.remove('live');
                domCache.liveStatusText.textContent = 'Error';
            }
        }

        function processLiveGameData(events) {
            const newUpdates = [];

            events.forEach(event => {
                const gameState = event.status.type.state;
                const gameTime = event.status.displayClock || '';
                const period = event.status.period || 1;


                if (gameState === 'in' || gameState === 'post') {
                    if (event.competitions && event.competitions[0]) {
                        const competition = event.competitions[0];

                                let allPlays = [];

                        if (competition.drives) {
                            const drives = [...(competition.drives.previous || []), ...(competition.drives.current || [])];
                            drives.forEach(drive => {
                                if (drive.plays) {
                                    allPlays.push(...drive.plays);
                                }
                            });
                        }

                        if (competition.plays) {
                            allPlays.push(...competition.plays);
                        }

                        if (competition.situation?.lastPlay) {
                            allPlays.push(competition.situation.lastPlay);
                        }


                        allPlays.forEach((play, index) => {
                            if (play && isFantasyRelevantPlay(play)) {
                                const update = createPlayUpdate(play, gameTime, period, event.name);
                                if (update) {
                                    if (shouldShowUpdate(update)) {
                                        newUpdates.push(update);
                                    } else {
                                    }
                                } else {
                                }
                            } else {
                            }
                        });

                    }
                }
            });


            if (newUpdates.length > 0) {
                addUpdatesToFeed(newUpdates);
            }
        }

        function isFantasyRelevantPlay(play) {
            if (!play.type || !play.text) return false;

            const relevantTypes = [
                'Rush', 'Pass', 'Touchdown', 'Field Goal', 'Safety',
                'Interception', 'Fumble', 'Sack', 'Two-Point Conversion'
            ];

            return relevantTypes.some(type =>
                play.type.text.includes(type) ||
                play.text.includes(type)
            );
        }

        function createPlayUpdate(play, gameTime, period, gameName) {
            const playText = play.text || '';
            const playerNames = extractPlayerNames(playText);


            let relevantPlayer = null;
            let playerData = null;
            let isMyPlayer = false;

            for (const extractedName of playerNames) {

                const matchedPlayer = Object.entries(playerStats).find(([id, stats]) => {
                    if (!stats.name) return false;

                    const statName = stats.name.toLowerCase();
                    const extractedLower = extractedName.toLowerCase();

                    if (statName === extractedLower) {
                        return true;
                    }

                    if (extractedName.includes('.')) {
                        const [firstInitial, lastName] = extractedName.split('.');
                        const statParts = statName.split(' ');

                        if (statParts.length >= 2 &&
                            statParts[0].toLowerCase().startsWith(firstInitial.toLowerCase()) &&
                            statParts[statParts.length - 1].toLowerCase() === lastName.toLowerCase()) {
                            return true;
                        }
                    }

                    const nameVariations = {
                        'dak prescott': ['d.prescott'],
                        'tony pollard': ['t.pollard'],
                        'alvin kamara': ['a.kamara'],
                        'sam darnold': ['s.darnold'],
                        'derrick henry': ['d.henry'],
                        'lamar jackson': ['l.jackson'],
                        'travis etienne': ['t.etienne'],
                        'spencer rattler': ['s.rattler'],
                        'trey mcbride': ['t.mcbride'],
                        'kyler murray': ['k.murray'],
                        'james conner': ['j.conner'],
                        'marvin harrison jr.': ['m.harrison', 'm.harrison jr.'],
                        "ja'marr chase": ['j.chase'],
                        'joe burrow': ['j.burrow'],
                        'chase brown': ['c.brown'],
                        'bo nix': ['b.nix'],
                        'patrick mahomes': ['p.mahomes'],
                        'travis kelce': ['t.kelce'],
                        'kareem hunt': ['k.hunt'],
                        'courtland sutton': ['c.sutton']
                    };

                    const variations = nameVariations[statName];
                    if (variations && variations.includes(extractedLower)) {
                        return true;
                    }

                    const statParts = statName.split(' ');
                    const extractedParts = extractedLower.split(' ');

                    if (statParts.length >= 2 && extractedParts.length >= 2) {
                        const firstMatch = statParts[0] === extractedParts[0];
                        const lastMatch = statParts[statParts.length - 1] === extractedParts[extractedParts.length - 1];
                        if (firstMatch && lastMatch) {
                            return true;
                        }
                    }

                    return false;
                });

                if (matchedPlayer) {
                    const [playerId, stats] = matchedPlayer;
                    relevantPlayer = extractedName;
                    playerData = stats;
                    isMyPlayer = myPlayers.hasOwnProperty(playerId);
                    break;
                } else {
                }
            }

            if (!relevantPlayer) {
                return null;
            }

            const points = calculatePlayPoints(play);

            let playerId = null;
            for (const [id, stats] of Object.entries(playerStats)) {
                if (stats === playerData) {
                    playerId = id;
                    break;
                }
            }

            const isOpponentPlayer = playerId ? opponentPlayers.hasOwnProperty(playerId) : false;


            const myPlayerData = myPlayers[playerId];
            const oppPlayerData = opponentPlayers[playerId];
            const isStarter = (myPlayerData?.isMyStarter) || (oppPlayerData?.isOpponentStarter);

            let leagueNames = '';
            if (isMyPlayer && myPlayerData) {
                leagueNames = `Own in: ${myPlayerData.ownedLeagues.join(', ')}`;
            } else if (isOpponentPlayer && oppPlayerData) {
                leagueNames = `Face in: ${oppPlayerData.opponentLeagues.join(', ')}`;
            } else if (myPlayerData && myPlayerData.ownedLeagues && myPlayerData.ownedLeagues.length > 0) {
                leagueNames = `Own in: ${myPlayerData.ownedLeagues.join(', ')}`;
            } else if (oppPlayerData && oppPlayerData.opponentLeagues && oppPlayerData.opponentLeagues.length > 0) {
                leagueNames = `Face in: ${oppPlayerData.opponentLeagues.join(', ')}`;
            }


            const playContentHash = btoa(playText.replace(/\s+/g, ' ').trim()).slice(0, 10);
            return {
                id: `${play.id}_${relevantPlayer}_${period}_${playContentHash}`,
                playerName: playerData?.name || relevantPlayer || 'Unknown Player',
                playText: playText,
                points: points,
                time: gameTime ? `Q${period} ${gameTime}` : `Q${period}`,
                timestamp: Date.now(),
                isMyPlayer: isMyPlayer,
                isOpponentPlayer: isOpponentPlayer,
                isStarter: isStarter,
                isScoring: points > 0,
                leagues: leagueNames,
                game: gameName || 'Game'
            };
        }

        function extractPlayerNames(text) {
            const abbreviatedPattern = /([A-Z]\.[A-Z][a-z]+)/g;
            const fullNamePattern = /([A-Z][a-z]+\s+[A-Z][a-z]+)/g;

            let names = [];

            const abbreviatedNames = text.match(abbreviatedPattern) || [];
            names.push(...abbreviatedNames);

            // Extract full names
            const fullNames = text.match(fullNamePattern) || [];
            names.push(...fullNames);

            const filtered = names.filter(name =>
                !name.includes('Shotgun') &&
                !name.includes('Huddle') &&
                !name.includes('Timeout') &&
                !name.includes('Update') &&
                !name.includes('England')
            );

            return filtered;
        }

        function calculatePlayPoints(play) {
            const text = play.text.toLowerCase();
            let points = 0;

            // Scoring plays
            if (text.includes('touchdown')) points += 6;
            if (text.includes('field goal') && text.includes('is good')) points += 3;
            if (text.includes('safety')) points += 2;
            if (text.includes('two-point')) points += 2;

            const yardMatches = text.match(/for (\d+) yard/g);
            if (yardMatches) {
                yardMatches.forEach(match => {
                    const yards = parseInt(match.match(/(\d+)/)[1]);

                    if (text.includes('pass') && !text.includes('scrambl')) {
                        points += yards * 0.04 + yards * 0.1;
                    } else if (text.includes('rush') || text.includes('scrambl') || text.includes('left') || text.includes('right') || text.includes('middle') || text.includes('tackle') || text.includes('guard') || text.includes('end')) {
                        points += yards * 0.1;
                    } else if (text.includes('receiv') || text.includes('catch')) {
                        points += 1 + yards * 0.1;
                    }
                });
            }

            // Receptions (PPR)
            if (text.includes('pass') && text.includes('complete') && !text.includes('incomplete')) {
                points += 1;
            }

            // Negative plays
            if (text.includes('interception') || text.includes('intercepted')) points -= 2;
            if (text.includes('fumble') && text.includes('lost')) points -= 2;
            if (text.includes('sack')) points -= 1;

            return Math.round(points * 10) / 10;
        }

        function shouldShowUpdate(update) {

            const filterMyPlayers = document.getElementById('filterMyPlayers').checked;
            const filterScoringPlays = document.getElementById('filterScoringPlays').checked;

            if (filterMyPlayers) {
                if (!update.isMyPlayer) {
                    return false;
                }
            } else {
                if (!update.isMyPlayer && !update.isOpponentPlayer) {
                    return false;
                }
            }

            if (filterScoringPlays && !update.isScoring) {
                return false;
            }

            return true;
        }

        function addUpdatesToFeed(updates) {
            const existingIds = new Set(liveFeedData.map(item => `${item.id}-${item.playerName}`));
            const newUpdates = updates.filter(update => {
                const updateId = `${update.id}-${update.playerName}`;
                return !existingIds.has(updateId);
            });


            if (newUpdates.length > 0) {
                liveFeedData.unshift(...newUpdates);
                liveFeedData = liveFeedData.slice(0, 50);

                renderNewUpdates(newUpdates);
            }
        }

        function renderNewUpdates(newUpdates) {
            const existingList = domCache.liveFeedList;

            newUpdates.forEach(update => {
                const classes = [];
                if (update.isScoring) classes.push('scoring');
                if (update.isMyPlayer) classes.push('my-player');
                if (update.isOpponentPlayer) classes.push('opponent-player');

                let indicator = '';
                if (update.points !== 0) {
                    const isGoodForUser = (update.isMyPlayer && update.points > 0) || (update.isOpponentPlayer && update.points < 0);

                    if (isGoodForUser) {
                        indicator = '<span class="player-indicator good">GOOD 📈</span>';
                    } else if (update.isMyPlayer || update.isOpponentPlayer) {
                        indicator = '<span class="player-indicator bad">BAD 📉</span>';
                    }
                }

                const pointsDisplay = update.points !== 0 ?
                    `<div class="update-points">${update.points > 0 ? '+' : ''}${update.points} pts</div>` : '';

                const leagueInfo = update.leagues ? `<div class="update-leagues">📍 ${update.leagues}</div>` : '';

                const newElement = document.createElement('div');
                newElement.className = `live-update-item ${classes.join(' ')}`;
                newElement.style.opacity = '0';
                newElement.innerHTML = `
                    <div class="update-header">
                        <span class="update-player">${update.playerName}${indicator}</span>
                        <span class="update-time">${update.time}</span>
                    </div>
                    ${leagueInfo}
                    <div class="update-details">${update.playText}</div>
                    ${pointsDisplay}
                `;

                existingList.insertBefore(newElement, existingList.firstChild);

                // Trigger animation
                requestAnimationFrame(() => {
                    newElement.style.transition = 'opacity 0.3s ease-in';
                    newElement.style.opacity = '1';
                });
            });

            while (existingList.children.length > 50) {
                existingList.removeChild(existingList.lastChild);
            }
        }

        function togglePlayerCard(cardElement) {
            const content = cardElement.querySelector('.player-card-content');
            const isCollapsed = cardElement.classList.contains('collapsed');

            if (isCollapsed) {
                cardElement.classList.remove('collapsed');
                cardElement.classList.add('expanded');
                content.classList.add('expanded');
            } else {
                cardElement.classList.add('collapsed');
                cardElement.classList.remove('expanded');
                content.classList.remove('expanded');
            }
        }

        function toggleAllCards(buttonElement, sectionClass) {
            const section = buttonElement.closest('.player-section');
            const cards = section.querySelectorAll('.player-card');
            const isExpandingAll = buttonElement.textContent.includes('Expand');

            cards.forEach(card => {
                const content = card.querySelector('.player-card-content');

                if (isExpandingAll) {
                    card.classList.remove('collapsed');
                    card.classList.add('expanded');
                    content.classList.add('expanded');
                } else {
                    card.classList.add('collapsed');
                    card.classList.remove('expanded');
                    content.classList.remove('expanded');
                }
            });

            buttonElement.textContent = isExpandingAll ? '🔼 Collapse All' : '🔽 Expand All';
        }

        function renderLiveFeed() {
            if (liveFeedData.length === 0) {
                domCache.liveFeedList.innerHTML = `
                    <div class="live-feed-placeholder">
                        <p>🏈 Live updates will appear here during game time</p>
                        <p style="font-size: 0.875rem; opacity: 0.7;">Updates refresh every 30 seconds</p>
                    </div>
                `;
                return;
            }

            let html = '';
            liveFeedData.forEach(update => {
                const classes = [];
                if (update.isScoring) classes.push('scoring');
                if (update.isMyPlayer) classes.push('my-player');
                if (update.isOpponentPlayer) classes.push('opponent-player');

                let indicator = '';
                if (update.points !== 0) {
                    const isGoodForUser = (update.isMyPlayer && update.points > 0) || (update.isOpponentPlayer && update.points < 0);

                    if (isGoodForUser) {
                        indicator = '<span class="player-indicator good">GOOD 📈</span>';
                    } else if (update.isMyPlayer || update.isOpponentPlayer) {
                        indicator = '<span class="player-indicator bad">BAD 📉</span>';
                    }
                }

                const pointsDisplay = update.points !== 0 ?
                    `<div class="update-points">${update.points > 0 ? '+' : ''}${update.points} pts</div>` : '';

                const leagueInfo = update.leagues ? `<div class="update-leagues">📍 ${update.leagues}</div>` : '';
                html += `
                    <div class="live-update-item ${classes.join(' ')}">
                        <div class="update-header">
                            <span class="update-player">${update.playerName}${indicator}</span>
                            <span class="update-time">${update.time}</span>
                        </div>
                        ${leagueInfo}
                        <div class="update-details">${update.playText}</div>
                        ${pointsDisplay}
                    </div>
                `;
            });

            domCache.liveFeedList.innerHTML = html;
        }
    </script>
</body>
</html>
