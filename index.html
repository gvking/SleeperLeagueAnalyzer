<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sleeper Fantasy Football Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: white;
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .header p {
            color: #cbd5e1;
            margin-bottom: 8px;
        }

        .week-info {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .input-section {
            background: #475569;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 32px;
        }

        .input-group {
            display: flex;
            gap: 16px;
        }

        input[type="text"] {
            flex: 1;
            padding: 8px 16px;
            border-radius: 6px;
            background: #334155;
            color: white;
            border: 1px solid #475569;
            font-size: 16px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        button {
            padding: 8px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        button:hover:not(:disabled) {
            background: #2563eb;
        }

        button:disabled {
            background: #64748b;
            cursor: not-allowed;
        }

        .error {
            margin-top: 16px;
            padding: 12px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 6px;
            color: #fca5a5;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-info {
            background: #475569;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-details h2 {
            font-size: 1.25rem;
            font-weight: bold;
        }

        .user-details .label {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 24px;
        }

        .player-section {
            border-radius: 8px;
            padding: 24px;
        }

        .player-section.my-players {
            background: linear-gradient(135deg, #064e3b 0%, #14532d 100%);
        }

        .player-section.opponent-players {
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .section-header h2 {
            font-size: 1.25rem;
            font-weight: bold;
            flex: 1;
        }

        .player-count {
            font-size: 0.875rem;
            opacity: 0.75;
        }

        .players-list {
            max-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: start;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .player-details {
            font-size: 0.875rem;
            opacity: 0.75;
            margin-bottom: 4px;
        }

        .player-leagues {
            font-size: 0.75rem;
            opacity: 0.6;
        }

        .player-points {
            text-align: right;
        }

        .points-value {
            font-size: 1.125rem;
            font-weight: bold;
        }

        .points-label {
            font-size: 0.75rem;
            opacity: 0.6;
        }

        .loading-text {
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .loading {
            animation: spin 1s linear infinite;
        }

        .empty-state {
            text-align: center;
            padding: 48px;
            color: #94a3b8;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }

        .hidden {
            display: none;
        }

        .ai-summary {
            background: linear-gradient(135deg, #1e40af 0%, #3730a3 100%);
            border-radius: 12px;
            margin-top: 32px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .ai-summary-header {
            padding: 20px 24px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }

        .ai-summary-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .ai-summary-header h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0;
        }

        .toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .toggle-icon.rotated {
            transform: rotate(180deg);
        }

        .ai-summary-content {
            padding: 0 24px 24px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .ai-summary-content.expanded {
            max-height: 1000px;
            transition: max-height 0.3s ease-in;
        }

        .summary-section {
            margin-bottom: 20px;
        }

        .summary-section:last-child {
            margin-bottom: 0;
        }

        .summary-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #e2e8f0;
        }

        .insight-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
            border-left: 4px solid #60a5fa;
        }

        .insight-item:last-child {
            margin-bottom: 0;
        }

        .insight-positive {
            border-left-color: #34d399;
            background: rgba(52, 211, 153, 0.1);
        }

        .insight-negative {
            border-left-color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .insight-neutral {
            border-left-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }

        .player-highlight {
            font-weight: 600;
            color: #fbbf24;
        }

        .icon {
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: middle;
        }

        .icon-trophy {
            color: #facc15;
        }

        .icon-trending-up {
            color: #4ade80;
        }

        .icon-trending-down {
            color: #f87171;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <svg class="icon icon-trophy" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94A5.01 5.01 0 0 0 11 15.9V19H7v2h10v-2h-4v-3.1a5.01 5.01 0 0 0 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z"/>
                </svg>
                Sleeper Fantasy Tracker
                <svg class="icon icon-trophy" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94A5.01 5.01 0 0 0 11 15.9V19H7v2h10v-2h-4v-3.1a5.01 5.01 0 0 0 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z"/>
                </svg>
            </h1>
            <p>Track all your players across multiple leagues</p>
            <p class="week-info" id="weekInfo"></p>
        </div>

        <div class="input-section" id="inputSection">
            <div class="input-group">
                <input type="text" id="usernameInput" placeholder="Enter your Sleeper username">
                <button id="loadButton" onclick="loadUserData()">
                    <span id="buttonText">Load Leagues</span>
                </button>
            </div>
            <div id="errorMessage" class="error hidden"></div>
        </div>

        <div class="user-info hidden" id="userInfo">
            <div class="user-details">
                <span class="label">Logged in as</span>
                <h2 id="displayName"></h2>
                <p class="label" id="leagueCount"></p>
            </div>
            <div style="display: flex; align-items: center; gap: 16px;">
                <div style="display: flex; align-items: center; gap: 16px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label for="weekSelector" style="font-size: 0.875rem; color: #cbd5e1;">Week:</label>
                        <select id="weekSelector" onchange="changeWeek()" style="padding: 4px 8px; border-radius: 4px; background: #334155; color: white; border: 1px solid #475569;">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="startersOnly" onchange="toggleStarters()" checked style="cursor: pointer;">
                        <label for="startersOnly" style="font-size: 0.875rem; color: #cbd5e1; cursor: pointer;">Starters Only</label>
                    </div>
                    <button onclick="resetApp()">Change User</button>
                </div>
            </div>
        </div>

        <div class="players-grid" id="playersGrid"></div>

        <!-- AI Summary Section -->
        <div class="ai-summary hidden" id="aiSummary">
            <div class="ai-summary-header" onclick="toggleAISummary()">
                <h3>ðŸ¤– Week Analysis & Strategy</h3>
                <span class="toggle-icon" id="summaryToggle">â–¼</span>
            </div>
            <div class="ai-summary-content" id="summaryContent">
                <div class="summary-section">
                    <h4>ðŸŽ¯ Key Players This Week</h4>
                    <div id="keyPlayers"></div>
                </div>
                <div class="summary-section">
                    <h4>ðŸ“Š Win Scenarios</h4>
                    <div id="winScenarios"></div>
                </div>
                <div class="summary-section">
                    <h4>âš¡ Week Outlook</h4>
                    <div id="weekOutlook"></div>
                </div>
            </div>
        </div>

        <div class="empty-state hidden" id="emptyState">
            <svg fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>
            </svg>
            <p>No active matchups found for this week</p>
            <p style="font-size: 0.875rem; margin-top: 8px;">Your leagues might not have started yet or matchups aren't set</p>
        </div>
    </div>

    <script>
        let currentWeek = 1;
        let selectedWeek = 1;
        let currentSeason = '2025';
        let currentSeasonType = 'regular';
        let userData = null;
        let leagues = [];
        let allPlayers = {};
        let myPlayers = {};
        let opponentPlayers = {};
        let playerStats = {};
        let nflSchedule = {};
        let isLoading = false;
        let aiSummaryExpanded = false;
        let showOnlyStarters = true;
        
        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('SleeperPlayerDB', 1);

                req.onerror = () => reject(req.error);
                req.onsuccess = () => resolve(req.result);

                req.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('players')) {
                        db.createObjectStore('players', { keyPath: 'season' });
                    }
                };
            });
        }
        
        async function getCachedPlayers(season) {
            try {
                const db = await openDB();
                const transaction = db.transaction(['players'], 'readonly');
                const store = transaction.objectStore('players');
                const req = store.get(season);

                return new Promise((resolve, reject) => {
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => resolve(req.result?.data);
                });
            } catch (error) {
                return null;
            }
        }
        
        async function cachePlayers(season, playerData) {
            try {
                const db = await openDB();
                const transaction = db.transaction(['players'], 'readwrite');
                const store = transaction.objectStore('players');
                store.put({ season, data: playerData, timestamp: Date.now() });
            } catch (error) {
                // Cache write failed - continue silently
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            fetchNFLState();

            const username = getUsernameFromURL();
            if (username) {
                document.getElementById('usernameInput').value = username;
                loadUserData();
            }

            document.getElementById('usernameInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    loadUserData();
                }
            });
        });
        
        function getUsernameFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            if (urlParams.has('username')) {
                return urlParams.get('username');
            }

            if (urlParams.has('user')) {
                return urlParams.get('user');
            }

            const firstParam = urlParams.keys().next().value;
            if (firstParam && !urlParams.get(firstParam)) {
                return firstParam;
            }

            const path = window.location.pathname;
            const hash = window.location.hash;

            const pathParts = path.split('/');
            if (pathParts.length > 1 && pathParts[pathParts.length - 1] && pathParts[pathParts.length - 1] !== 'index.html') {
                return pathParts[pathParts.length - 1];
            }

            if (hash && hash.startsWith('#')) {
                return hash.substring(1);
            }

            return null;
        }
        
        function updateURL(username) {
            if (!username) return;

            const url = new URL(window.location);
            url.searchParams.set('username', username);
            window.history.replaceState({username: username}, '', url.toString());
        }

        async function fetchNFLState() {
            try {
                const response = await fetch('https://api.sleeper.app/v1/state/nfl');
                const data = await response.json();
                
                currentWeek = data.week || 1;
                selectedWeek = currentWeek; // Default to current week
                currentSeason = data.season || '2025';
                currentSeasonType = data.season_type || 'regular';
                
                // Fetch NFL schedule for the season
                await fetchNFLSchedule();
                
                updateWeekInfo();
            } catch (error) {
                console.error('Error fetching NFL state:', error);
                currentSeason = '2025';
                currentSeasonType = 'regular';
                currentWeek = 1;
                selectedWeek = 1;

                await fetchNFLSchedule();
                
                updateWeekInfo();
            }
        }
        
        async function fetchNFLSchedule() {
            const hardcodedSchedule = {
                1: { 
                    'KC': { opponent: 'BAL', isHome: true }, 'BAL': { opponent: 'KC', isHome: false },
                    'LAR': { opponent: 'DET', isHome: true }, 'DET': { opponent: 'LAR', isHome: false },
                    'PHI': { opponent: 'GB', isHome: true }, 'GB': { opponent: 'PHI', isHome: false },
                    'BUF': { opponent: 'ARI', isHome: true }, 'ARI': { opponent: 'BUF', isHome: false },
                    'PIT': { opponent: 'ATL', isHome: true }, 'ATL': { opponent: 'PIT', isHome: false },
                    'MIN': { opponent: 'NYG', isHome: true }, 'NYG': { opponent: 'MIN', isHome: false },
                    'IND': { opponent: 'HOU', isHome: true }, 'HOU': { opponent: 'IND', isHome: false },
                    'JAX': { opponent: 'MIA', isHome: true }, 'MIA': { opponent: 'JAX', isHome: false },
                    'CLE': { opponent: 'DAL', isHome: true }, 'DAL': { opponent: 'CLE', isHome: false },
                    'CAR': { opponent: 'NO', isHome: true }, 'NO': { opponent: 'CAR', isHome: false },
                    'CHI': { opponent: 'TEN', isHome: true }, 'TEN': { opponent: 'CHI', isHome: false },
                    'NE': { opponent: 'CIN', isHome: true }, 'CIN': { opponent: 'NE', isHome: false },
                    'LV': { opponent: 'LAC', isHome: true }, 'LAC': { opponent: 'LV', isHome: false },
                    'TB': { opponent: 'WAS', isHome: true }, 'WAS': { opponent: 'TB', isHome: false },
                    'SF': { opponent: 'NYJ', isHome: true }, 'NYJ': { opponent: 'SF', isHome: false },
                    'SEA': { opponent: 'DEN', isHome: true }, 'DEN': { opponent: 'SEA', isHome: false }
                },
                2: {
                    'KC': { opponent: 'CIN', isHome: true }, 'CIN': { opponent: 'KC', isHome: false },
                    'BUF': { opponent: 'MIA', isHome: true }, 'MIA': { opponent: 'BUF', isHome: false },
                    'BAL': { opponent: 'LV', isHome: true }, 'LV': { opponent: 'BAL', isHome: false },
                    'LAC': { opponent: 'CAR', isHome: true }, 'CAR': { opponent: 'LAC', isHome: false },
                    'NO': { opponent: 'DAL', isHome: true }, 'DAL': { opponent: 'NO', isHome: false },
                    'NYG': { opponent: 'WAS', isHome: true }, 'WAS': { opponent: 'NYG', isHome: false },
                    'IND': { opponent: 'GB', isHome: true }, 'GB': { opponent: 'IND', isHome: false },
                    'DET': { opponent: 'TB', isHome: true }, 'TB': { opponent: 'DET', isHome: false },
                    'ATL': { opponent: 'PHI', isHome: true }, 'PHI': { opponent: 'ATL', isHome: false },
                    'CLE': { opponent: 'JAX', isHome: true }, 'JAX': { opponent: 'CLE', isHome: false },
                    'HOU': { opponent: 'CHI', isHome: true }, 'CHI': { opponent: 'HOU', isHome: false },
                    'TEN': { opponent: 'NYJ', isHome: true }, 'NYJ': { opponent: 'TEN', isHome: false },
                    'NE': { opponent: 'SEA', isHome: true }, 'SEA': { opponent: 'NE', isHome: false },
                    'DEN': { opponent: 'PIT', isHome: true }, 'PIT': { opponent: 'DEN', isHome: false },
                    'SF': { opponent: 'MIN', isHome: true }, 'MIN': { opponent: 'SF', isHome: false },
                    'LAR': { opponent: 'ARI', isHome: true }, 'ARI': { opponent: 'LAR', isHome: false }
                }
            };
            
            nflSchedule = hardcodedSchedule;
        }
        
        function getPlayerMatchup(playerTeam, week) {
            if (!nflSchedule[week] || !nflSchedule[week][playerTeam]) {
                return null;
            }
            
            const matchup = nflSchedule[week][playerTeam];
            const vs = matchup.isHome ? 'vs' : '@';
            return `${playerTeam} ${vs} ${matchup.opponent}`;
        }
        
        function generateFallbackProjection(position, team) {
            const positionAverages = {
                'QB': { min: 14, max: 28, avg: 19.5 },
                'RB': { min: 5, max: 22, avg: 12.8 },
                'WR': { min: 6, max: 20, avg: 11.4 },
                'TE': { min: 4, max: 16, avg: 9.2 },
                'K': { min: 6, max: 12, avg: 8.5 },
                'DEF': { min: 4, max: 15, avg: 8.8 }
            };

            const pos = positionAverages[position] || positionAverages['WR'];

            const teamHash = team ? team.split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0) : 42;

            const pseudoRandom = Math.abs(teamHash % 1000) / 1000;

            const range = pos.max - pos.min;
            const projection = pos.min + (pseudoRandom * range);

            return Math.round(projection * 10) / 10;
        }

        function updateWeekInfo() {
            const weekInfo = document.getElementById('weekInfo');
            if (selectedWeek === currentWeek) {
                weekInfo.textContent = `NFL Week ${selectedWeek} (Current) Â· ${currentSeason} Season`;
            } else if (selectedWeek < currentWeek) {
                weekInfo.textContent = `NFL Week ${selectedWeek} (Past) Â· ${currentSeason} Season`;
            } else {
                weekInfo.textContent = `NFL Week ${selectedWeek} (Future) Â· ${currentSeason} Season`;
            }
        }

        function populateWeekSelector() {
            const weekSelector = document.getElementById('weekSelector');
            weekSelector.innerHTML = '';

            for (let week = 1; week <= 18; week++) {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                if (week === selectedWeek) {
                    option.selected = true;
                }
                weekSelector.appendChild(option);
            }
        }

        async function changeWeek() {
            if (isLoading) return;

            const weekSelector = document.getElementById('weekSelector');
            selectedWeek = parseInt(weekSelector.value);
            updateWeekInfo();

            if (userData) {
                isLoading = true;
                showLoadingState();

                try {
                    await processLeagues();
                    displayPlayers();
                } catch (error) {
                    console.error('Error loading week data:', error);
                } finally {
                    hideLoadingState();
                    isLoading = false;
                }
            }
        }
        
        function showLoadingState() {
            const grid = document.getElementById('playersGrid');
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 48px; color: #94a3b8;">
                    <div class="loading" style="width: 40px; height: 40px; margin: 0 auto 16px; border: 3px solid #475569; border-top: 3px solid #3b82f6; border-radius: 50%;"></div>
                    <p>Loading Week ${selectedWeek} data...</p>
                    <p style="font-size: 0.875rem; margin-top: 8px; opacity: 0.7;">Fetching matchups and player stats</p>
                </div>
            `;
        }
        
        function hideLoadingState() {
            // Placeholder
        }

        async function loadUserData() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) return;

            const button = document.getElementById('loadButton');
            const buttonText = document.getElementById('buttonText');
            const errorDiv = document.getElementById('errorMessage');

            errorDiv.classList.add('hidden');
            button.disabled = true;
            buttonText.innerHTML = '<span class="loading-text">âŸ³</span> Loading...';

            try {
                const userResponse = await fetch(`https://api.sleeper.app/v1/user/${username}`);
                if (!userResponse.ok) throw new Error('Failed to connect to Sleeper API');
                userData = await userResponse.json();

                if (!userData || !userData.user_id) {
                    throw new Error(`User "${username}" not found. Please check the username and try again.`);
                }

                const leaguesResponse = await fetch(`https://api.sleeper.app/v1/user/${userData.user_id}/leagues/nfl/${currentSeason}`);
                leagues = await leaguesResponse.json();

                if (!leagues || !Array.isArray(leagues)) {
                    leagues = [];
                }

                await processLeagues();

                displayUserInfo();
                populateWeekSelector();
                displayPlayers();

                updateURL(username);

            } catch (error) {
                errorDiv.textContent = error.message || 'An error occurred';
                errorDiv.classList.remove('hidden');
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Load Leagues';
            }
        }

        async function processLeagues() {
            allPlayers = {};
            myPlayers = {};
            opponentPlayers = {};

            for (const league of leagues) {
                try {
                    const rostersResponse = await fetch(`https://api.sleeper.app/v1/league/${league.league_id}/rosters`);
                    const rosters = await rostersResponse.json();

                    const matchupsResponse = await fetch(`https://api.sleeper.app/v1/league/${league.league_id}/matchups/${selectedWeek}`);
                    const matchups = await matchupsResponse.json();

                    if (!matchups || !Array.isArray(matchups) || matchups.length === 0) {
                        continue;
                    }

                    const myRoster = rosters.find(r => r.owner_id === userData.user_id);

                    if (myRoster && myRoster.players) {
                        const myMatchup = matchups.find(m => m.roster_id === myRoster.roster_id);
                        const myStarters = myMatchup?.starters || [];

                        myRoster.players.forEach(playerId => {
                            if (!allPlayers[playerId]) {
                                allPlayers[playerId] = { 
                                    ownedLeagues: [], 
                                    opponentLeagues: [], 
                                    starterOwnedLeagues: [], 
                                    starterOpponentLeagues: [],
                                    isMyStarter: false, 
                                    isOpponentStarter: false 
                                };
                            }
                            allPlayers[playerId].ownedLeagues.push(league.name);

                            if (myStarters.includes(playerId)) {
                                allPlayers[playerId].isMyStarter = true;
                                allPlayers[playerId].starterOwnedLeagues.push(league.name);
                            }
                        });

                        if (myMatchup) {
                            const opponentMatchup = matchups.find(m =>
                                m.matchup_id === myMatchup.matchup_id && m.roster_id !== myRoster.roster_id
                            );

                            if (opponentMatchup) {
                                const opponentRoster = rosters.find(r => r.roster_id === opponentMatchup.roster_id);
                                if (opponentRoster && opponentRoster.players) {
                                    const opponentStarters = opponentMatchup.starters || [];

                                    opponentRoster.players.forEach(playerId => {
                                        if (!allPlayers[playerId]) {
                                            allPlayers[playerId] = { 
                                                ownedLeagues: [], 
                                                opponentLeagues: [], 
                                                starterOwnedLeagues: [], 
                                                starterOpponentLeagues: [],
                                                isMyStarter: false, 
                                                isOpponentStarter: false 
                                            };
                                        }
                                        allPlayers[playerId].opponentLeagues.push(league.name);

                                        if (opponentStarters.includes(playerId)) {
                                            allPlayers[playerId].isOpponentStarter = true;
                                            allPlayers[playerId].starterOpponentLeagues.push(league.name);
                                        }
                                    });
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Error processing league ${league.name}:`, error);
                }
            }

            const allPlayerIds = Object.keys(allPlayers);
            if (allPlayerIds.length > 0) {
                await fetchPlayerStats(allPlayerIds);
            }

            Object.entries(allPlayers).forEach(([playerId, data]) => {
                if (showOnlyStarters && !data.isMyStarter && !data.isOpponentStarter) {
                    return;
                }

                const playerInfo = playerStats[playerId];
                if (!playerInfo || !playerInfo.name || playerInfo.name.includes('undefined') || playerInfo.name === 'N/A') {
                    return;
                }
                
                let ownedCount, opponentCount, ownedLeagues, opponentLeagues;

                if (showOnlyStarters) {
                    ownedCount = data.starterOwnedLeagues.length;
                    opponentCount = data.starterOpponentLeagues.length;
                    ownedLeagues = data.starterOwnedLeagues;
                    opponentLeagues = data.starterOpponentLeagues;
                } else {
                    ownedCount = data.ownedLeagues.length;
                    opponentCount = data.opponentLeagues.length;
                    ownedLeagues = data.ownedLeagues;
                    opponentLeagues = data.opponentLeagues;
                }

                const netImpact = ownedCount - opponentCount;
                const totalLeagues = [...ownedLeagues, ...opponentLeagues];

                if (netImpact > 0) {
                    myPlayers[playerId] = {
                        netImpact: netImpact,
                        totalCount: totalLeagues.length,
                        ownedCount: ownedCount,
                        opponentCount: opponentCount,
                        ownedLeagues: ownedLeagues,
                        opponentLeagues: opponentLeagues,
                        allLeagues: totalLeagues,
                        isMyStarter: data.isMyStarter,
                        isOpponentStarter: data.isOpponentStarter
                    };
                } else if (netImpact < 0) {
                    opponentPlayers[playerId] = {
                        netImpact: netImpact,
                        totalCount: totalLeagues.length,
                        ownedCount: ownedCount,
                        opponentCount: opponentCount,
                        ownedLeagues: ownedLeagues,
                        opponentLeagues: opponentLeagues,
                        allLeagues: totalLeagues,
                        isMyStarter: data.isMyStarter,
                        isOpponentStarter: data.isOpponentStarter
                    };
                }
            });
            
        }

        async function fetchPlayerStats(playerIds) {
            try {
                let playerDatabase;
                const cachedPlayers = await getCachedPlayers(currentSeason);

                if (cachedPlayers) {
                    playerDatabase = cachedPlayers;
                } else {
                    const playersResponse = await fetch('https://api.sleeper.app/v1/players/nfl');
                    playerDatabase = await playersResponse.json();
                    await cachePlayers(currentSeason, playerDatabase);
                }
                
                let weekStats = {};

                if (selectedWeek <= currentWeek) {
                    try {
                        const statsResponse = await fetch(`https://api.sleeper.app/v1/stats/nfl/${currentSeasonType}/${currentSeason}/${selectedWeek}`);
                        weekStats = await statsResponse.json() || {};
                    } catch (error) {
                        weekStats = {};
                    }
                }
                
                let realProjections = {};
                let missingPlayerIds = [...playerIds];
                let retryAttempt = 0;
                const maxRetries = 5;
                const batchSize = 15;
                const delayBetweenRetries = 2000;
                
                while (missingPlayerIds.length > 0 && retryAttempt < maxRetries) {
                    retryAttempt++;

                    for (let i = 0; i < missingPlayerIds.length; i += batchSize) {
                        const batch = missingPlayerIds.slice(i, i + batchSize);
                        
                        const batchPromises = batch.map(async (playerId) => {
                            try {
                                const projUrl = `https://api.sleeper.com/projections/nfl/player/${playerId}?season_type=${currentSeasonType}&season=${currentSeason}&grouping=week`;
                                const response = await fetch(projUrl);
                                if (response.ok) {
                                    const data = await response.json();
                                    if (data && data[selectedWeek] && data[selectedWeek].stats) {
                                        return { playerId, projection: data[selectedWeek].stats };
                                    }
                                }
                            } catch (error) {
                                // Network error, return null
                            }
                            return { playerId, projection: null };
                        });
                        
                        const batchResults = await Promise.all(batchPromises);
                        
                        batchResults.forEach(result => {
                            if (result.projection) {
                                realProjections[result.playerId] = result.projection;
                            }
                        });

                        if (i + batchSize < missingPlayerIds.length) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                    
                    const newMissingPlayerIds = playerIds.filter(id => !realProjections[id]);

                    if (newMissingPlayerIds.length === missingPlayerIds.length && retryAttempt > 1) {
                        break;
                    }

                    missingPlayerIds = newMissingPlayerIds;

                    if (missingPlayerIds.length > 0 && retryAttempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenRetries));
                    }
                }
                
                playerStats = {};
                
                playerIds.forEach(playerId => {
                    const playerInfo = playerDatabase[playerId];
                    const stats = weekStats[playerId];
                    const proj = realProjections[playerId];
                    
                    if (playerInfo) {
                        let actualPoints = 0;
                        let projectedPoints = 0;
                        
                        if (stats) {
                            actualPoints = calculateFantasyPoints(stats, playerInfo.position);
                        }

                        if (proj) {
                            projectedPoints = proj.pts_ppr || proj.pts_half_ppr || proj.pts_std || 0;
                        } else {
                            return;
                        }
                        
                        let displayPoints = 0;
                        if (selectedWeek > currentWeek) {
                            displayPoints = projectedPoints;
                        } else if (selectedWeek === currentWeek) {
                            displayPoints = actualPoints > 0 ? actualPoints : projectedPoints;
                        } else {
                            displayPoints = actualPoints;
                        }
                        const matchup = getPlayerMatchup(playerInfo.team, selectedWeek);
                        
                        playerStats[playerId] = {
                            name: `${playerInfo.first_name} ${playerInfo.last_name}`,
                            position: playerInfo.position,
                            team: playerInfo.team || 'FA',
                            points: displayPoints,
                            actualPoints: actualPoints,
                            projectedPoints: projectedPoints,
                            status: playerInfo.injury_status,
                            matchup: matchup
                        };
                    }
                });
            } catch (error) {
                console.error('Error fetching player stats:', error);
            }
        }
        
        function calculateFantasyPoints(statObj, position) {
            if (!statObj) return 0;

            if (position === 'K') {
                return (
                    (statObj.fgm || 0) * 3 +
                    (statObj.xpm || 0) * 1 +
                    (statObj.fgm_0_19 || 0) * 3 +
                    (statObj.fgm_20_29 || 0) * 3 +
                    (statObj.fgm_30_39 || 0) * 3 +
                    (statObj.fgm_40_49 || 0) * 4 +
                    (statObj.fgm_50p || 0) * 5 +
                    (statObj.pts_ppr || 0)
                );
            } else if (position === 'DEF') {
                return (
                    (statObj.def_int || 0) * 2 +
                    (statObj.def_fr || 0) * 2 +
                    (statObj.def_sack || 0) * 1 +
                    (statObj.def_safety || 0) * 2 +
                    (statObj.def_td || 0) * 6 +
                    (statObj.def_blk || 0) * 2 +
                    (statObj.pts_ppr || 0)
                );
            } else {
                return (
                    (statObj.pass_yd || 0) * 0.04 +
                    (statObj.pass_td || 0) * 4 +
                    (statObj.pass_int || 0) * -1 +
                    (statObj.rush_yd || 0) * 0.1 +
                    (statObj.rush_td || 0) * 6 +
                    (statObj.rec || 0) * 1 +
                    (statObj.rec_yd || 0) * 0.1 +
                    (statObj.rec_td || 0) * 6 +
                    (statObj.fum_lost || 0) * -2 +
                    (statObj.pts_ppr || 0)
                );
            }
        }

        function displayUserInfo() {
            document.getElementById('inputSection').classList.add('hidden');
            document.getElementById('userInfo').classList.remove('hidden');
            document.getElementById('displayName').textContent = userData.display_name;
            document.getElementById('leagueCount').textContent = `${leagues.length} active league${leagues.length !== 1 ? 's' : ''}`;
        }

        function displayPlayers() {
            const grid = document.getElementById('playersGrid');
            grid.innerHTML = '';

            if (Object.keys(myPlayers).length === 0 && Object.keys(opponentPlayers).length === 0) {
                const emptyState = document.getElementById('emptyState');
                emptyState.classList.remove('hidden');
                document.getElementById('aiSummary').classList.add('hidden');
                
                const emptyMessage = emptyState.querySelector('p');
                const emptySubtext = emptyState.querySelector('p:last-child');

                if (selectedWeek > currentWeek) {
                    emptyMessage.textContent = `No matchups found for Week ${selectedWeek}`;
                    emptySubtext.textContent = 'Matchups for future weeks may not be set yet';
                } else if (selectedWeek < currentWeek) {
                    emptyMessage.textContent = `No matchups found for Week ${selectedWeek}`;
                    emptySubtext.textContent = 'This week may have been a bye week or matchups are not available';
                } else {
                    emptyMessage.textContent = 'No active matchups found for this week';
                    emptySubtext.textContent = 'Your leagues might not have started yet or matchups aren\'t set';
                }
                return;
            }

            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('aiSummary').classList.remove('hidden');

            if (Object.keys(myPlayers).length > 0) {
                grid.innerHTML += createPlayerSection(
                    myPlayers,
                    'Players You Want to Succeed (Net Positive Impact)',
                    'my-players',
                    'trending-up'
                );
            }

            if (Object.keys(opponentPlayers).length > 0) {
                grid.innerHTML += createPlayerSection(
                    opponentPlayers,
                    'Players You Want to Fail (Net Negative Impact)',
                    'opponent-players',
                    'trending-down'
                );
            }
        }

        function createPlayerSection(players, title, className, iconType) {
            const sortedPlayers = Object.entries(players)
                .map(([id, data]) => ({
                    id,
                    ...data,
                    ...(playerStats[id] || {})
                }))
                .sort((a, b) => {
                    const aStrategicImpact = Math.abs(a.netImpact || 0) * (a.points || 0);
                    const bStrategicImpact = Math.abs(b.netImpact || 0) * (b.points || 0);

                    if (bStrategicImpact !== aStrategicImpact) {
                        return bStrategicImpact - aStrategicImpact;
                    }

                    const aNetImpact = Math.abs(a.netImpact || 0);
                    const bNetImpact = Math.abs(b.netImpact || 0);
                    if (bNetImpact !== aNetImpact) {
                        return bNetImpact - aNetImpact;
                    }

                    return (b.points || 0) - (a.points || 0);
                });

            const iconSvg = iconType === 'trending-up' 
                ? '<svg class="icon icon-trending-up" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>'
                : '<svg class="icon icon-trending-down" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 17h8m0 0v-8m0 8l-8-8-4 4-6-6"></path></svg>';

            let html = `
                <div class="player-section ${className}">
                    <div class="section-header">
                        ${iconSvg}
                        <h2>${title}</h2>
                        <span class="player-count">${sortedPlayers.length} players</span>
                    </div>
                    <div class="players-list">
            `;

            sortedPlayers.forEach(player => {
                html += `
                    <div class="player-card" title="Player ID: ${player.id}">
                        <div class="player-info">
                            <div class="player-name">${player.name || `Player ${player.id}`}</div>
                            <div class="player-details">
                                ${player.position || 'N/A'} - ${player.team}
                                ${player.status ? ` (${player.status})` : ''}
                            </div>
                            <div class="player-matchup" style="font-size: 0.75rem; color: #94a3b8; margin-top: 2px;">
                                ${player.matchup || 'Bye Week'}
                            </div>
                            <div class="player-leagues">
                                Net Impact: ${player.netImpact > 0 ? '+' : ''}${player.netImpact} 
                                (Own: ${player.ownedCount}, Face: ${player.opponentCount})
                            </div>
                            <div class="player-leagues" style="font-size: 0.7rem; margin-top: 2px;">
                                ${player.ownedCount > 0 ? `Own in: ${player.ownedLeagues.join(', ')}` : ''}
                                ${player.ownedCount > 0 && player.opponentCount > 0 ? ' | ' : ''}
                                ${player.opponentCount > 0 ? `Face in: ${player.opponentLeagues.join(', ')}` : ''}
                            </div>
                            <div style="font-size: 0.65rem; opacity: 0.5; margin-top: 2px; font-family: monospace;">
                                ID: ${player.id}
                            </div>
                        </div>
                        <div class="player-points">
                            <div class="points-value">${(player.points || 0).toFixed(1)}</div>
                            <div class="points-label">
                                ${selectedWeek > currentWeek ? 'proj' : 
                                  selectedWeek === currentWeek && player.actualPoints === 0 && player.projectedPoints > 0 ? 'proj' : 'pts'}
                            </div>
                            ${selectedWeek === currentWeek && player.actualPoints > 0 && player.projectedPoints > 0 ? 
                                `<div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">proj: ${player.projectedPoints.toFixed(1)}</div>` : ''}
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            return html;
        }
        
        function generateAISummary() {
            const allPlayers = [...Object.entries(myPlayers), ...Object.entries(opponentPlayers)]
                .map(([id, data]) => ({
                    id,
                    ...data,
                    ...(playerStats[id] || {})
                }))
                .sort((a, b) => {
                    const aImpact = Math.abs(a.netImpact || 0) * (a.points || 0);
                    const bImpact = Math.abs(b.netImpact || 0) * (b.points || 0);
                    return bImpact - aImpact;
                });
            
            generateKeyPlayers(allPlayers);
            generateWinScenarios();
            generateWeekOutlook(allPlayers);
        }
        
        function generateKeyPlayers(allPlayers) {
            const keyPlayersDiv = document.getElementById('keyPlayers');
            const topPlayers = allPlayers.slice(0, 5);
            
            let html = '';
            topPlayers.forEach((player, index) => {
                const impact = Math.abs(player.netImpact || 0);
                const points = player.points || 0;
                const totalImpact = impact * points;
                
                let insightClass = 'insight-neutral';
                let message = '';
                
                if (player.netImpact > 0) {
                    insightClass = 'insight-positive';
                    message = `You need <span class="player-highlight">${player.name}</span> to have a big week! They're in ${player.ownedCount} of your lineups vs ${player.opponentCount} opponent roster${player.opponentCount !== 1 ? 's' : ''}. Projected: ${points.toFixed(1)} pts`;
                } else if (player.netImpact < 0) {
                    insightClass = 'insight-negative';
                    message = `Hope <span class="player-highlight">${player.name}</span> struggles - they're on ${player.opponentCount} opponent team${player.opponentCount !== 1 ? 's' : ''} vs ${player.ownedCount} of yours. Projected: ${points.toFixed(1)} pts`;
                }
                
                if (message) {
                    html += `<div class="insight-item ${insightClass}">${message}</div>`;
                }
            });
            
            keyPlayersDiv.innerHTML = html;
        }
        
        function generateWinScenarios() {
            const winScenariosDiv = document.getElementById('winScenarios');
            
            const positiveImpact = Object.values(myPlayers).reduce((sum, player) => {
                return sum + (Math.abs(player.netImpact) * (playerStats[Object.keys(myPlayers).find(id => myPlayers[id] === player)]?.points || 0));
            }, 0);

            const negativeImpact = Object.values(opponentPlayers).reduce((sum, player) => {
                return sum + (Math.abs(player.netImpact) * (playerStats[Object.keys(opponentPlayers).find(id => opponentPlayers[id] === player)]?.points || 0));
            }, 0);
            
            const totalLeagues = leagues.length;
            const myPlayersCount = Object.keys(myPlayers).length;
            const opponentPlayersCount = Object.keys(opponentPlayers).length;
            
            let html = '';
            
            if (positiveImpact > negativeImpact * 1.2) {
                html += `<div class="insight-item insight-positive">
                    <strong>ðŸŽ¯ Strong Week Ahead:</strong> Your key players are projected for ${positiveImpact.toFixed(0)} total impact points. If they hit projections, you could win ${Math.ceil(totalLeagues * 0.7)}-${totalLeagues} leagues.
                </div>`;
            } else if (negativeImpact > positiveImpact * 1.2) {
                html += `<div class="insight-item insight-negative">
                    <strong>âš ï¸ Challenging Week:</strong> Opponents have ${negativeImpact.toFixed(0)} total impact points vs your ${positiveImpact.toFixed(0)}. You'll need some players to exceed projections.
                </div>`;
            } else {
                html += `<div class="insight-item insight-neutral">
                    <strong>âš–ï¸ Balanced Week:</strong> Close matchup with ${positiveImpact.toFixed(0)} vs ${negativeImpact.toFixed(0)} impact points. Could go either way - expect to win ${Math.floor(totalLeagues * 0.4)}-${Math.ceil(totalLeagues * 0.6)} leagues.
                </div>`;
            }
            
            if (myPlayersCount > opponentPlayersCount * 1.5) {
                html += `<div class="insight-item insight-positive">
                    <strong>ðŸ“ˆ High Upside:</strong> You have ${myPlayersCount} players with positive impact vs ${opponentPlayersCount} negative. Good week for ceiling plays.
                </div>`;
            }
            
            winScenariosDiv.innerHTML = html;
        }
        
        function generateWeekOutlook(allPlayers) {
            const weekOutlookDiv = document.getElementById('weekOutlook');
            
            const positionAnalysis = {};
            allPlayers.forEach(player => {
                const pos = player.position || 'Unknown';
                if (!positionAnalysis[pos]) {
                    positionAnalysis[pos] = { positive: 0, negative: 0, totalImpact: 0 };
                }
                
                const impact = (player.netImpact || 0) * (player.points || 0);
                positionAnalysis[pos].totalImpact += Math.abs(impact);
                
                if (player.netImpact > 0) {
                    positionAnalysis[pos].positive++;
                } else if (player.netImpact < 0) {
                    positionAnalysis[pos].negative++;
                }
            });
            
            let topPosition = null;
            let maxImpact = 0;
            Object.entries(positionAnalysis).forEach(([pos, data]) => {
                if (data.totalImpact > maxImpact) {
                    maxImpact = data.totalImpact;
                    topPosition = { pos, ...data };
                }
            });
            
            let html = '';
            
            if (selectedWeek > currentWeek) {
                html += `<div class="insight-item insight-neutral">
                    <strong>ðŸ”® Future Week ${selectedWeek}:</strong> Planning ahead! Monitor injury reports and weather as the week approaches.
                </div>`;
            } else if (selectedWeek === currentWeek) {
                html += `<div class="insight-item insight-positive">
                    <strong>âš¡ This Week:</strong> Games are live! Monitor player status and make any last-minute lineup adjustments.
                </div>`;
            } else {
                html += `<div class="insight-item insight-neutral">
                    <strong>ðŸ“Š Week ${selectedWeek} Results:</strong> Reviewing past performance to identify trends.
                </div>`;
            }
            
            if (topPosition && topPosition.totalImpact > 50) {
                const ratio = topPosition.positive / (topPosition.negative || 1);
                if (ratio > 2) {
                    html += `<div class="insight-item insight-positive">
                        <strong>ðŸˆ ${topPosition.pos} Advantage:</strong> You have strong ${topPosition.pos} exposure with ${topPosition.positive} positive vs ${topPosition.negative} negative impact players.
                    </div>`;
                } else if (ratio < 0.5) {
                    html += `<div class="insight-item insight-negative">
                        <strong>âš ï¸ ${topPosition.pos} Concern:</strong> Heavy opposing ${topPosition.pos} exposure (${topPosition.negative} vs ${topPosition.positive}). Monitor this position closely.
                    </div>`;
                }
            }
            
            weekOutlookDiv.innerHTML = html;
        }
        
        function toggleAISummary() {
            const content = document.getElementById('summaryContent');
            const toggle = document.getElementById('summaryToggle');
            
            aiSummaryExpanded = !aiSummaryExpanded;
            
            if (aiSummaryExpanded) {
                content.classList.add('expanded');
                toggle.classList.add('rotated');
                generateAISummary();
            } else {
                content.classList.remove('expanded');
                toggle.classList.remove('rotated');
            }
        }

        function toggleStarters() {
            showOnlyStarters = document.getElementById('startersOnly').checked;
            
            if (userData && Object.keys(allPlayers).length > 0) {
                myPlayers = {};
                opponentPlayers = {};
                
                Object.entries(allPlayers).forEach(([playerId, data]) => {
                    if (showOnlyStarters && !data.isMyStarter && !data.isOpponentStarter) {
                        return;
                    }

                    const playerInfo = playerStats[playerId];
                    if (!playerInfo || !playerInfo.name || playerInfo.name.includes('undefined') || playerInfo.name === 'N/A') {
                        return;
                    }
                    let ownedCount, opponentCount, ownedLeagues, opponentLeagues;
                    
                    if (showOnlyStarters) {
                        ownedCount = data.starterOwnedLeagues.length;
                        opponentCount = data.starterOpponentLeagues.length;
                        ownedLeagues = data.starterOwnedLeagues;
                        opponentLeagues = data.starterOpponentLeagues;
                    } else {
                        ownedCount = data.ownedLeagues.length;
                        opponentCount = data.opponentLeagues.length;
                        ownedLeagues = data.ownedLeagues;
                        opponentLeagues = data.opponentLeagues;
                    }
                    
                    const netImpact = ownedCount - opponentCount;
                    const totalLeagues = [...ownedLeagues, ...opponentLeagues];
                    
                    if (netImpact > 0) {
                        myPlayers[playerId] = {
                            netImpact: netImpact,
                            totalCount: totalLeagues.length,
                            ownedCount: ownedCount,
                            opponentCount: opponentCount,
                            ownedLeagues: ownedLeagues,
                            opponentLeagues: opponentLeagues,
                            allLeagues: totalLeagues,
                            isMyStarter: data.isMyStarter,
                            isOpponentStarter: data.isOpponentStarter
                        };
                    } else if (netImpact < 0) {
                        opponentPlayers[playerId] = {
                            netImpact: netImpact,
                            totalCount: totalLeagues.length,
                            ownedCount: ownedCount,
                            opponentCount: opponentCount,
                            ownedLeagues: ownedLeagues,
                            opponentLeagues: opponentLeagues,
                            allLeagues: totalLeagues,
                            isMyStarter: data.isMyStarter,
                            isOpponentStarter: data.isOpponentStarter
                        };
                    }
                });
                
                displayPlayers();
            }
        }

        function resetApp() {
            userData = null;
            leagues = [];
            allPlayers = {};
            myPlayers = {};
            opponentPlayers = {};
            playerStats = {};
            nflSchedule = {};
            isLoading = false;
            
            document.getElementById('usernameInput').value = '';
            document.getElementById('inputSection').classList.remove('hidden');
            document.getElementById('userInfo').classList.add('hidden');
            document.getElementById('playersGrid').innerHTML = '';
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('aiSummary').classList.add('hidden');
            
            const url = new URL(window.location);
            url.search = '';
            window.history.replaceState({}, '', url.toString());
        }
    </script>
</body>
</html>
